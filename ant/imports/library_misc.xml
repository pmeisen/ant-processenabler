<!--
  Library which adds some nice to have macros and targets 
  
  Created on: 01.03.2012
  Created by: Philipp Meisen <philipp@meisen.net>
  History:
    01.03.2012
      - Creation of library
  -->
<project name="library_misc">
  <property name="misc.library.version" value="1.2.0" description="The current version of the library" />
  <dirname property="library_misc.basedir" file="${ant.file.library_misc}"/>
  
  <!--
    generateUUID - generates a UUID and sets the passed property to the specified value
    -->
  <scriptdef name="generateUUID" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");

    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(java.util.UUID.randomUUID().toString());
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="incProperty" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");
    var propValue = project.getProperty(property);
    
    var value = Number(propValue == null ? 0 : propValue);
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(value + 1);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="decProperty" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");
    var propValue = project.getProperty(property);
    
    var value = Number(propValue == null ? 0 : propValue);
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(value - 1);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    setLogLevel - specifies the logging level to be used by ant
    -->
  <scriptdef name="setLogLevel" language="javascript">
    <attribute name="logLevel"/>
    <![CDATA[
    var loglevel = attributes.get("loglevel");
    
    // the default is 2 ==> warn
    var loglevelValue = 2;
    if (loglevel == "error") {
      loglevelValue = 0;
    } else if (loglevel == "warn") {
      loglevelValue = 1;
    } else if (loglevel == "info") {
      loglevelValue = 2;
    } else if (loglevel == "verbose") {
      loglevelValue = 3;
    } else if (loglevel == "debug") {
      loglevelValue = 4;
    }
    
    // set the logLevel
    var listener = project.getBuildListeners();
    var firstListener = listener.get(0);
    firstListener.setMessageOutputLevel(loglevelValue);
    
    ]]>
  </scriptdef>
  
  <scriptdef name="checkTarget" language="javascript">
    <attribute name="property" />
    <attribute name="target" />
    <![CDATA[
    // the property to be set and the target to be checked
    var userProperty = attributes.get("property");
    var target = attributes.get("target");
    
    // the property to be read
    var property = "ant.project.cmd-invoked-targets";
    
    // get the property
    var foundEntry = false;
    var invokedTargets = project.getProperty(property);
    if (invokedTargets == null || invokedTargets.equals("")) {
    
      // create an error logger
      var errorMsg = project.createTask("echo");
      var error = Packages.org.apache.tools.ant.taskdefs.Echo.EchoLevel(); 
      error.setValue("error");
      errorMsg.setLevel(error);
      errorMsg.setMessage("The " + property + " is not available, please check the used starting routine and the used main-class.");
      errorMsg.perform();
    } else {
    
      // check the list of targets
      var listEntries = invokedTargets.split("\\s*,\\s*");
      var sizeOfList = listEntries.length;
      for (var i = 0; i < sizeOfList && !foundEntry; i++) {
        var entry = listEntries[i];
        foundEntry = foundEntry || entry.equals(target);
      }
    }
    
    // set the userProperty
    project.setProperty(userProperty, "" + foundEntry);    
    ]]>
  </scriptdef>
  
  <!--
    transformPackageToPath - transforms the passed (comma-separated) packages to a path which selects all
                             files (incl. files in sub-directories) from the package
    -->
  <scriptdef name="transformPackagesToPath" language="javascript">
    <attribute name="property" />
    <attribute name="packages" />
    <attribute name="suffix" />
    <attribute name="packageSeparatore" />
    <attribute name="separatore" />
    
    <![CDATA[
    var property = attributes.get("property");
    var packs = attributes.get("packages");
    var suffix = attributes.get("suffix");
    var packageSeparatore = attributes.get("packageseparatore");
    var separatore = attributes.get("separatore");
        
    if (packs == null || packs.trim() == "") {
      project.setProperty(property, "");
    } else {
      var split = packs.split(",");
      
      var pack = "";
      packs = "";
      for (var i = 0; i < split.length; i++) {
        pack = split[i].trim();
        pack = pack.replace('.', packageSeparatore);
        pack += suffix;
        
        packs += (packs == "" ? "" : separatore) + pack;
      }
      
      project.setProperty(property, packs);
    }
    ]]>
  </scriptdef>
  
  <!--
    createList - Creates a list based on an already created list, by appending a value to it only and 
                 only if its not in the list yet. The newly created list will never end on the passed separator
    -->
  <scriptdef name="createList" language="javascript">
    <attribute name="property" />
    <attribute name="list" />
    <attribute name="value" />
    <attribute name="separatore" />
    
    <![CDATA[
    var property = attributes.get("property");
    var list = attributes.get("list");
    var separatore = attributes.get("separatore");
    var value = attributes.get("value");
    value = value.trim();

    var listEntries = list.split("\\s*" + separatore + "\\s*");
    
    var finalList = "";
    var sizeOfList = listEntries.length;
    var foundEntry = false;
    for (var i = 0; i < sizeOfList; i++) {
      var entry = listEntries[i];
      var lastEntry = sizeOfList - 1 == i;
      foundEntry = foundEntry || entry.equals(value);
      
      finalList += entry + (lastEntry ? "" : separatore);
    }
    
    if (!foundEntry) {
      finalList += (sizeOfList > 0 && !finalList.equals("") ? separatore : "") + value;
    }
    
    project.setProperty(property, finalList);
    ]]>
  </scriptdef>
  
  <macrodef name="importLibrariesFromList">
    <attribute name="list" />
    <attribute name="default" default="true" />
    <attribute name="force" default="false" />
  
    <sequential>

      <for list="@{list}" param="misc.tmp.library">
        <sequential>
          <!-- reset the properties -->
          <var name="misc.tmp.relfile" value="" unset="true" />
          <var name="misc.tmp.import" value="" unset="true" />
          
          <!-- get the values of the defined properties -->
          <propertycopy name="misc.tmp.relfile" from="main.library.file.@{misc.tmp.library}" />
          <propertycopy name="misc.tmp.import" from="main.import.library.@{misc.tmp.library}" silent="true" />
          
          <!-- get the file and import it -->
          <if>
            <or>
              <equals arg1="@{force}" arg2="true" />
              <and>
                <isset property="misc.tmp.import" />
                <not><equals arg1="${misc.tmp.import}" arg2="false" /></not>
              </and>
              <and>
                <equals arg1="@{default}" arg2="true" />
                <not><isset property="misc.tmp.import" /></not>
              </and>
            </or>
            <then>
              <echo level="debug">Importing library: ${misc.tmp.relfile}</echo>
              <var name="misc.tmp.file" value="${library_main.basedir}/${misc.tmp.relfile}" />
              <import file="${misc.tmp.file}" />
            </then>
          </if>
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <macrodef name="allLibrariesFiles">
    <attribute name="filesetid" />
  
    <sequential>
      <var name="misc.tmp.libraries" value="main,${main.import.order.core},${main.import.order.extension},${main.import.order.general},${main.import.order.proxy}" />
      
      <fileset id="@{filesetid}" dir="${main.root}">
        <exclude name="**/*" />
      </fileset>
     
      <for list="${misc.tmp.libraries}" param="misc.tmp.library">
        <sequential>
          <propertycopy name="misc.tmp.import" from="main.import.library.@{misc.tmp.library}" silent="true" />
            
          <if>
            <not><equals arg1="${misc.tmp.library}" arg2="" /></not>
            <then>
              <libraryFiles library="@{misc.tmp.library}" filesetid="misc.tmp.libraryFiles" />

              <!-- create the unions -->
              <fileCombineFilesets filesetId="@{filesetid}">
                <fileset refid="misc.tmp.libraryFiles" />
                <fileset refid="@{filesetid}" />
              </fileCombineFilesets>
            </then>
          </if>
        </sequential>
      </for>            
    </sequential>
  </macrodef>
  
  <macrodef name="libraryFiles">
    <attribute name="library" />
    <attribute name="filesetid" />
  
    <sequential>
      <var name="misc.tmp.library.files" value="" unset="true" />
    
      <propertyset id="misc.tmp.library.files">
        <propertyref regex="^@{library}\.library\.resfile\..+$" />
        <propertyref regex="^ant\.file\.library_@{library}$" />
      </propertyset>
 
      <!-- convert it to a path -->
      <pathconvert refid="misc.tmp.library.files" pathsep="," property="misc.tmp.library.files">
        <regexpmapper from="^\Q${main.root}\E[\\/](.+)$" to="\1"/>
      </pathconvert>

      <!-- get the fileset -->
      <fileset id="@{filesetid}" dir="${main.root}" includes="${misc.tmp.library.files}" />
    </sequential>
  </macrodef>
</project>