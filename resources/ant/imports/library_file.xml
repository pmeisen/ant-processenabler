<!--
  Library which adds some macros and targets for file operations/modifications
  
  Created on: 01.03.2012
  Created by: Philipp Meisen <philipp@meisen.net>
  History:
    01.03.2012
      - Creation of library
    03.01.2013
      - added new macros for file manipulation
  -->
<project name="library_file">
  <property name="file.library.version" value="2.0.0" description="The current version of the library" />
  <dirname property="library_file.basedir" file="${ant.file.library_file}" />
  
  <property name="file.library.resfile.default.merge" location="${library_eclipse.basedir}/library_file_xmlMerge.properties" />
  <property name="file.library.resfile.js.general" location="${main.root}/javascripts/library_file/general.js" description="JavaScript with some helper methods for files" />
  
  <property name="file.replacement.default.pattern" value="\.xml|\.properties|\.htm|\.html|\.txt|\.bat|\.mf|\.project|\.classpath|\.template|\.sh" />

  <!--
    add the antcontrib library
    -->
  <taskdef resource="net/sf/antcontrib/antlib.xml" />
  <!--
    include additional tasks
    -->
  <taskdef name="xmlmerge" classname="ch.elca.el4j.services.xmlmerge.anttask.XmlMergeTask" />
  
  <!--
    fileCleanUp - should be called to clean a directory (i.e. deletes all files and directories)
    -->
  <macrodef name="fileCleanUp">
    <attribute name="file" default="" />
    <attribute name="dir" default="" />
    <element name="files" implicit="true" optional="true" />
    
    <attribute name="failonerror" default="true" />
    <attribute name="includeEmptyDirs" default="true" />
    <attribute name="recreate" default="true" />

    <sequential>
    
      <!-- check if we have a file to be deleted -->
      <if>
        <not><equals arg1="@{file}" arg2="" /></not>
        <then>
          <echo level="info">Cleaning file '@{file}'</echo>
          
          <!-- sometimes the OS blocks deleting so we wait a little and retry a couple of times -->
          <retry retrycount="10" retrydelay="500">
            <delete file="@{file}" failonerror="@{failonerror}" />
          </retry>
        </then>
      </if>
      
      <!-- check if a folder is specified as well -->
      <if>
        <not><equals arg1="@{dir}" arg2="" /></not>
        <then>
          <echo level="info">Cleaning folder '@{dir}'</echo>
          
          <!-- sometimes the OS blocks deleting so we wait a little and retry a couple of times -->
          <retry retrycount="10" retrydelay="500">
            <delete dir="@{dir}" includeEmptyDirs="@{includeEmptyDirs}" failonerror="@{failonerror}" />
          </retry>
        </then>
      </if>
      
      <!-- check if a fileset is specified -->
      <trycatch property="maven.tmp.error" reference="maven.tmp.errReference">
        <try>
          
          <!-- we just do some task which fails if no fileset was specified -->
          <resourcecount property="file.tmp.foundFileSetCount">
            <files />
          </resourcecount>
          <var name="file.tmp.foundFileSet" value="true" />
        </try>
        <catch>
          <var name="file.tmp.foundFileSet" value="false" />
        </catch>
        <finally />
      </trycatch>
      <if>
        <equals arg1="${file.tmp.foundFileSet}" arg2="true" />
        <then>
          <echo level="info">Cleaning fileset</echo>
          
          <!-- sometimes the OS blocks deleting so we wait a little and retry a couple of times -->
          <retry retrycount="10" retrydelay="500">
            <delete includeEmptyDirs="@{includeEmptyDirs}" failonerror="@{failonerror}">
              <files />
            </delete>
          </retry>
        </then>
      </if>
      
      <!-- check if recreation has to be done, only valid for a directory -->
      <if>
        <and>
          <not><equals arg1="@{dir}" arg2="" /></not>
          <or><equals arg1="@{recreate}" arg2="y" /><equals arg1="@{recreate}" arg2="yes" /><equals arg1="@{recreate}" arg2="true" /></or>
        </and>
        <then>
            <mkdir dir="@{dir}" />
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="fileCheckFiles">
    <attribute name="files" />
    <attribute name="delimiter" default="|" />
    <attribute name="property" default="file.tmp.fileexists" />
    <attribute name="fail" default="false" />
    
    <sequential>
      <for list="@{files}" param="file.tmp.checkFiles.file" delimiter="@{delimiter}" trim="true">
        <sequential>
        
          <if>
            <available file="@{file.tmp.checkFiles.file}" />
            <then>
              <var name="@{property}" value="true" />
            </then>
            <elseif>
              <or><equals arg1="@{fail}" arg2="true" /><equals arg1="@{fail}" arg2="y" /><equals arg1="@{fail}" arg2="yes" /></or>
              <then>
                <fail>The file '@{file.tmp.checkFiles.file}' does not exist</fail>
              </then>
            </elseif>
            <else>
              <var name="@{property}" value="false" />
            </else>
          </if>
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <macrodef name="fileAppendLine">   
    <attribute name="file" />
    <attribute name="line" />
    <attribute name="create" default="true" />

    <sequential>

      <if>
        <or>
          <available file="@{file}" />
          <equals arg1="@{create}" arg2="true" />
          <equals arg1="@{create}" arg2="y" />
          <equals arg1="@{create}" arg2="yes" />
        </or>
        <then>
          <echo level="debug">Adding line: '@{line}' to @{file}</echo>
<!-- the format is applied to the file so there shouldn't be any extra whitespaces -->
<echo file="@{file}" append="true">@{line}
</echo>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="filePrintFileset">   
    <attribute name="filesetid" />

    <sequential>
    
      <!-- print the fileset -->
      <pathconvert pathsep="${line.separator}" property="file.tmp.fileset" refid="@{filesetid}"/>
      <echo>${file.tmp.fileset}</echo>
      
      <var name="file.tmp.fileset" unset="true" />
    </sequential>
  </macrodef>
  
  <!--
    fileUnzipZipFileTo - unzips a zip-file to the specified comma-separated locations
    -->
  <macrodef name="fileUnzipZipFileTo">
    <attribute name="zipFile" />
    <attribute name="locations" />

    <sequential>
    
      <if>
        <not><equals arg1="@{locations}" arg2="" /></not>
        <then>
          <for list="@{locations}" param="file.tmp.unzipTo" trim="true">
            <sequential>
              <mkdir dir="@{file.tmp.unzipTo}" />
              <unzip src="@{zipFile}" dest="@{file.tmp.unzipTo}" overwrite="true" />
            </sequential>
          </for>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="fileZipLocations">
    <attribute name="zipLocations" />
    <attribute name="destLocation" />
    <attribute name="destFilePrefix" default="file" />
    
    <sequential>
    
      <if>
        <not><equals arg1="@{zipLocations}" arg2="" /></not>
        <then>
          <var name="file.tmp.zipCounter" value="" unset="true" />
          <for list="@{zipLocations}" param="file.tmp.zip" trim="true">
            <sequential>
              <if>
                <available file="@{file.tmp.zip}"/>
                <then>
                  <incProperty property="file.tmp.zipCounter" />
                  <zip destfile="@{destLocation}/@{destFilePrefix}_${file.tmp.zipCounter}.zip" basedir="@{file.tmp.zip}" />
                </then>
              </if>
            </sequential>
          </for>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <!--
    fileReplaceAllProperties - creates a copy of the specified file, whereby all known ant-properties are replaced
    -->
  <macrodef name="fileReplaceAllProperties">
    <attribute name="file" />
    <attribute name="destFile" />
    <attribute name="tmp" default="${main.tmpdir}" />
    <attribute name="force" default="false" />
    <attribute name="encoding" default="" />
    <attribute name="filePattern" default="${file.replacement.default.pattern}" />

    <sequential>
      <var name="file.tmp.doReplace" value="false" />
      
      <if>
        <not><length file="@{file}" when="greater" length="0" /></not>
        <then>
          <!-- files with zero length cannot be property-replaced -->
          <echo level="debug">File @{file} has size of 0 and no properties will be replaced</echo>
        </then>
        <else>
          <if>
            <or>
              <equals arg1="@{force}" arg2="true" />
              <equals arg1="@{force}" arg2="y" />
              <equals arg1="@{force}" arg2="yes" />
              <matches string="@{file}" pattern="(?:@{filePattern})$" casesensitive="false" />
            </or>
            <then>
                        
              <!-- determine the encoding of the file -->
              <if>
                <equals arg1="@{encoding}" arg2="" />
                <then>
                  <if>
                    <matches string="@{file}" pattern="(?:\.xml)$" casesensitive="false" />
                    <then><fileXmlEncoding xmlfile="@{file}" property="file.tmp.replaceEncoding" /></then>
                    <else><fileEncoding file="@{file}" property="file.tmp.replaceEncoding" /></else>
                  </if>
                </then>
                <else>
                  <var name="file.tmp.replaceEncoding" value="@{encoding}" />
                </else>
              </if>
              
              <!-- check if the file contains any properties -->
              <var name="file.tmp.replaceContainsProperty" value="" unset="true" />
              <loadfile property="file.tmp.replaceContainsProperty" srcfile="@{file}" encoding="${file.tmp.replaceEncoding}">  
                <filterchain>  
                  <linecontainsregexp>
                    <regexp pattern="\$\{.*\}"/>  
                  </linecontainsregexp>
                </filterchain>
              </loadfile>
              
              <!-- we have to replace if there are properties -->
              <if>
                <isset property="file.tmp.replaceContainsProperty" />
                <then>
                  <var name="file.tmp.doReplace" value="true" />
                </then>
              </if>
            </then>
          </if>
        </else>
      </if>
      
      <!-- check if we have to replace, otherwise just copy if necessary -->
      <if>
        <equals arg1="${file.tmp.doReplace}" arg2="true" />
        <then>

          <!-- replace all the properties of the file specified -->
          <copy file="@{file}" tofile="${main.tmpdir}/file.tmp" overwrite="true" encoding="${file.tmp.replaceEncoding}" >
            <filterchain>
              <expandproperties/>
            </filterchain>
          </copy>
          
          <copy file="${main.tmpdir}/file.tmp" tofile="@{destFile}" overwrite="true" />
        </then>
        <elseif>
          <not><equals arg1="@{file}" arg2="@{destFile}" /></not>
          <then>
            <copy file="@{file}" tofile="@{destFile}" overwrite="true" />
          </then>
        </elseif>
      </if>
    </sequential>
  </macrodef>
    
  <macrodef name="fileGetFileName">
    <attribute name="file" />
    <attribute name="property" />

    <sequential>
      <var name="@{property}" value="" unset="true" />
      <basename property="@{property}" file="@{file}"/>
    </sequential>
  </macrodef>
  
  <macrodef name="fileReplaceAllPropertiesInZip">
    <attribute name="file" />
    <attribute name="dest" />
    <attribute name="tmp" default="${main.tmpdir}" />
    <attribute name="rezip" default="true" />
    <attribute name="excludes" default="" />
    <attribute name="filePattern" default="${file.replacement.default.pattern}" />

    <sequential>
    
      <if>
        <matches string="@{file}" pattern="(?:\.zip|\.jar)$" casesensitive="false" />
        <then>
          <!-- generate a temporary directory -->
          <generateUUID property="file.tmp.stagingArea" />
          <var name="file.tmp.stagingArea" value="${main.tmpdir}/${file.tmp.stagingArea}" />
          <fileCleanUp dir="${file.tmp.stagingArea}" />
          
          <if>
            <or><equals arg1="@{rezip}" arg2="y" /><equals arg1="@{rezip}" arg2="yes" /><equals arg1="@{rezip}" arg2="true" /></or>
            <then>
              <generateUUID property="file.tmp.destLocation" />
              <var name="file.tmp.destLocation" value="${main.tmpdir}/${file.tmp.destLocation}" />
              <fileCleanUp dir="${file.tmp.destLocation}" />
            </then>
            <else>
              <var name="file.tmp.destLocation" value="@{dest}" />
            </else>
          </if>

          <!-- first copy the once with possibility to replace -->
          <unzip src="@{file}" dest="${file.tmp.stagingArea}" overwrite="true" />
          
          <!-- now replace each file -->
          <for param="zippedFile">
            <path>
              <fileset dir="${file.tmp.stagingArea}" />
            </path>
            <sequential>
              <fileReplaceAllProperties file="@{zippedFile}" destFile="@{zippedFile}" filePattern="@{filePattern}" />
            </sequential>
          </for>

          <!-- copy and replace properties -->
          <copy todir="${file.tmp.destLocation}">
            <fileset dir="${file.tmp.stagingArea}" />
          </copy>
          
          <!-- zip the stuff -->
          <if>
            <or><equals arg1="@{rezip}" arg2="y" /><equals arg1="@{rezip}" arg2="yes" /><equals arg1="@{rezip}" arg2="true" /></or>
            <then>
              <zip destfile="@{dest}" basedir="${file.tmp.destLocation}" />
              
              <!-- cleanup the location -->
              <fileCleanUp dir="${file.tmp.destLocation}" recreate="false" />
            </then>
          </if>
          
          <!-- cleanUp -->
          <fileCleanUp dir="${file.tmp.stagingArea}" recreate="false" />
        </then>
        <else>
          <echo level="warn">You are trying to replace properties in a file which is not a zip or a jar</echo>
        </else>
      </if>
    </sequential>
  </macrodef>

  <macrodef name="fileMergeXml">
    <attribute name="file1" />
    <attribute name="file2" />
    <attribute name="dest" />
    <attribute name="conf" default="${file.library.resfile.default.merge}" />

    <sequential>
    
      <!-- check if file2 really exists -->
      <if>
        <available file="@{file2}"/>
        <then>
          
          <!-- create the new merge -->
          <xmlmerge dest="${main.tmpdir}/file.tmp" conf="@{conf}">
            <fileset file="@{file1}" />
            <fileset file="@{file2}" />
          </xmlmerge>
          
          <!-- get the new file -->
          <fileCleanUp file="@{dest}" />
          <move file="${main.tmpdir}/file.tmp" tofile="@{dest}" overwrite="true" />
        </then>
        <else>
          <copy file="@{file1}" tofile="@{dest}" overwrite="true" />
        </else>
      </if>
    </sequential>
  </macrodef>
    
  <macrodef name="runAnt">
    <attribute name="directory" default="." />
    <attribute name="targets" />
    <attribute name="parameters" default="" />
    <attribute name="dirPattern" default=".*" />
    <attribute name="subDirectories" default="trunk" />
    <attribute name="failOnError" default="true" />
  
    <sequential>
      <var name="dirname" value="" unset="true" />
      <basename file="@{directory}" property="dirname"/>
      
      <var name="buildDir" value="@{directory}/@{subDirectories}" />
      <var name="buildFile" value="${buildDir}/build.xml" />

      <if>
        <and>
          <matches pattern="@{dirPattern}" string="${dirname}"/>
          <resourceexists>
            <file file="${buildFile}"/>
          </resourceexists>
        </and>
        <then>
          <echo level="info">Running targets @{targets} for ${dirname}</echo>
          <var name="file.tmp.runAntError" unset="true" />
          <var name="file.tmp.runAntResult" unset="true" />
          <exec dir="${buildDir}" executable="cmd.exe" resultproperty="file.tmp.runAntResult" errorproperty="file.tmp.runAntError">
            <arg line="/c &quot;${ant.home}/bin/ant&quot; @{targets} @{parameters}"/>
          </exec>
          
          <if>
            <and>
              <isset property="file.tmp.runAntResult" />
              <not><equals arg1="${file.tmp.runAntResult}" arg2="0" /></not>
              <or><equals arg1="@{failOnError}" arg2="true" /><equals arg1="@{failOnError}" arg2="yes" /><equals arg1="@{failOnError}" arg2="y" /></or>
            </and>
            <then>            
              <fail>${file.tmp.runAntError}</fail>
            </then>
            <else>
              <echo level="debug">Executed ant at ${dirname} with @{targets} [Return-Code: ${file.tmp.runAntResult} (${file.tmp.runAntError})]</echo>
            </else>
          </if>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="doTargetForEachFolder">
    <attribute name="includes" default="*" />
    <attribute name="excludes" default="" />
    <attribute name="targets" />
    <attribute name="parameters" default="" />
    <attribute name="dirPattern" default=".*" />
    <attribute name="projectSubDirectories" default="trunk" />
    <attribute name="rootDirectories" default="." />
    <attribute name="failOnError" default="true" />
    
    <sequential>
      <var name="file.tmp.wrapperTargets" value="@{targets}" />
      <var name="file.tmp.wrapperParameters" value="@{parameters}" />
      <var name="file.tmp.wrapperDirPattern" value="@{dirPattern}" />
      <var name="file.tmp.projectSubDirectories" value="@{projectSubDirectories}" />
      <var name="file.tmp.failOnError" value="@{failOnError}" />

      <for param="directory">
        <path>
          <dirset dir="@{rootDirectories}" includes="@{includes}" excludes="@{excludes}" />
        </path>
        <sequential>
          <runAnt directory="@{directory}" targets="${file.tmp.wrapperTargets}" parameters="${file.tmp.wrapperParameters}" 
                  dirPattern="${file.tmp.wrapperDirPattern}" subDirectories="${file.tmp.projectSubDirectories}" 
                  failOnError="${file.tmp.failOnError}" />
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <scriptdef name="fileInfo" language="javascript">
    <attribute name="file" />
    
    <![CDATA[   
      var fileName = attributes.get("file");
      var file = new java.io.File(fileName);
      
      var setFileName = project.createTask("var");
      setFileName.setName("fileInfo.name");
      setFileName.setValue(file.getName());
      setFileName.execute();
      
      var ext = file.getName();
      var i = ext.lastIndexOf(".");
      if (i > 0 && i < ext.length() - 1) {
        ext = ext.substring(i + 1).toLowerCase();
      } else {
        ext = "";
      }
      var setFileExtension = project.createTask("var");
      setFileExtension.setName("fileInfo.extension");
      setFileExtension.setValue(ext);
      setFileExtension.execute();
      
      var setFileType = project.createTask("var");
      setFileType.setName("fileInfo.dir");
      setFileType.setValue(file.isDirectory());
      setFileType.execute();
      
      var setFileExists = project.createTask("var");
      setFileExists.setName("fileInfo.exist");
      setFileExists.setValue(file.exists());
      setFileExists.execute();
      
      var setFileDir = project.createTask("var");
      setFileDir.setName("fileInfo.directory");
      setFileDir.setValue(file.isDirectory() ? file.getAbsolutePath() : file.getParent());
      setFileDir.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileFilterFilesetByDirset" language="javascript">
    <attribute name="filteredSetId" />
    <attribute name="filteredSetBase" />
    <element name="fileset" type="fileset" />
    <element name="dirset" type="dirset" />
    
    <![CDATA[
      var filesets = elements.get("fileset");
      var dirsets = elements.get("dirset");
      var filteredSetId = attributes.get("filteredsetid");
      var filteredSetBase = attributes.get("filteredsetbase");
      
      // create the new fileset
      var fsFiltered = project.createDataType("fileset");
      fsFiltered.setDir(new java.io.File(filteredSetBase));
      // fsFiltered.setExcludes("**/*");
      project.addReference(filteredSetId, fsFiltered);
      
      // check each file
      var addedCount = 0;
      for (i = 0; i < filesets.size(); ++i) {
        var fileset = filesets.get(i);
        var fsBaseDir = fileset.getDir(project);
        
        // get the files of the set
        var fsScanner = fileset.getDirectoryScanner(project);
        var fsFiles = fsScanner.getIncludedFiles();
       
        // check each file
        for (j = 0; j < fsFiles.length; ++j) {
          var fileName = fsFiles[j];
          var file = new java.io.File(fsBaseDir, fileName);
        
          // check if the file is within the dirsets
          var found = false;
          for (k = 0; k < dirsets.size() && !found; ++k) {
            var dirset = dirsets.get(k);
            var dsBaseDir = dirset.getDir(project);
            
            // get the directories of the set
            var dsScanner = dirset.getDirectoryScanner(project);
            var dsDir = dsScanner.getIncludedDirectories();

            // check all the directories
            for (l = 0; l < dsDir.length && !found; ++l) {
              var dirName = dsDir[l];
              var dir = new java.io.File(dsBaseDir, dirName);
              
              // check if the file is located within the directory
              var parent = file.getParentFile();
              while(!found && parent != null) {
                  if(dir.equals(parent)) {
                      found = true;
                  }

                  parent = parent.getParentFile();
              }
            }
          }
          
          // add the file
          if (!found) {
            var absPath = file.getAbsolutePath();
            if (absPath.startsWith(filteredSetBase)) {
              var inc = fsFiltered.createInclude();
              inc.setName(absPath.substring(filteredSetBase.length() + 1).replace("\\", "/"));
              
              // incremeant the count
              addedCount++;
            }
          }
        }
      }
      
      // check if we added something
      if (addedCount == 0) {
        var ex = fsFiltered.createExclude();
        ex.setName("**/*");
      }
    ]]>
  </scriptdef>

  <scriptdef name="fileCallMacroForEach" language="javascript">
    <attribute name="macro" />
    <!-- the following attributes are optional -->
    <attribute name="regExpFilter" />
    <attribute name="parameters" />
    <element name="fileset" type="fileset" />
    
    <![CDATA[
      var macro = attributes.get("macro");
      var regExpFilter = attributes.containsKey("regexpfilter") ? attributes.get("regexpfilter") : ".*";
      var parameters = attributes.containsKey("parameters") ? attributes.get("parameters") : "";
      var parameterList = parameters.equals("") ? new Array() : parameters.split("\\]\\]\\s*(;\\s*|\\s*$)");
      var filesets = elements.get("fileset");
      
      for (i = 0; i < filesets.size(); ++i) {
        var fileset = filesets.get(i);
        var baseDir = fileset.getDir(project);
      
        // get the files of the set
        var scanner = fileset.getDirectoryScanner(project);
        var files = scanner.getIncludedFiles();

        // check each file
        for (j = 0; j < files.length; ++j) {
          var file = files[j];
          var src = new java.io.File(baseDir, file);

          // check the pattern
          if (src.getAbsolutePath().matches(regExpFilter)) {
            var runMacro = project.createTask(macro);
           
            var attributes = runMacro.getMacroDef().getAttributes();
            for (var i = 0; i < attributes.size(); ++i) {
              var att = attributes.get(i);
              
              if (att == null) {
                continue;
              } else if (att.getName().equals("resourcefolder")) {
                runMacro.setDynamicAttribute("resourcefolder", src.getParent());
              } else if (att.getName().equals("resourcefilename")) {
                runMacro.setDynamicAttribute("resourcefilename", src.getName());
              } else if (att.getName().equals("resource")) {
                runMacro.setDynamicAttribute("resource", src);
              } else if (att.getName().equals("basedir")) {
                runMacro.setDynamicAttribute("basedir", baseDir);
              }
            }
            
            // set the dynamic values
            for (i = 0; i < parameterList.length; ++i) {
              var keyValue = parameterList[i].split("\\s*=\\s*\\[\\[");             
              runMacro.setDynamicAttribute(keyValue[0].toLowerCase(), keyValue[1]);
            }
            
            runMacro.execute();
          }
        }
      }
    ]]>
  </scriptdef>
  
  <scriptdef name="fileGetSubPath" language="javascript">
    <attribute name="basedir" />
    <attribute name="file" />
    <!-- the following attributes are optional -->
    <attribute name="isDir" />
    <attribute name="property" />
    <attribute name="removePrefix" />
    
    <![CDATA[
      // helper method to load js files
      // thanks to http://stackoverflow.com/questions/650377/javascript-rhino-use-library-or-include-other-scripts
      var l = function(property) {
        var jsFile = project.getProperty(property);
        var fileReader = new java.io.FileReader(jsFile);
        var fullRead = org.apache.tools.ant.util.FileUtils.readFully(fileReader);
        
        return "" + new java.lang.String(fullRead);
      }
      
      // load the libraries
      eval(l("file.library.resfile.js.general"));
    
      // get the properties and execute the function
      var basedir = attributes.get("basedir");
      var file = attributes.get("file");
      var property = attributes.containsKey("property") ? attributes.get("property") : "file.subpath";
      var isdir = attributes.containsKey("isdir") ? attributes.get("isdir") : "" + (new java.io.File(file).isDirectory());
      var removePrefix = attributes.containsKey("removeprefix") ? attributes.get("removeprefix") : "";

      // get the booleans
      isdir = isdir != null && (isdir.equals("true") || isdir.equals("yes"), isdir.equals("y"));
      
      // call the script
      var relativePath = getSubPath(basedir, file, isdir, removePrefix);

      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(relativePath);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileCreateFileList" language="javascript">
    <attribute name="dir" />
    <attribute name="property" />
    <!-- the following attributes are optional -->
    <attribute name="basedir" />
    <attribute name="basedirReplacement" />
    
    <![CDATA[
      var property = attributes.get("property");
      var dir = attributes.get("dir");
      var dirFile = new java.io.File(dir);
      var basedir = attributes.containsKey("basedir") ? attributes.get("basedir") : dirFile.getPath();
      var basedirreplacement = attributes.containsKey("basedirreplacement") ? attributes.get("basedirreplacement") : "";
      
      // get the list
      var csvFiles = "";
      var stack = new java.util.Stack();
      stack.push(dirFile);
      while(!stack.isEmpty()) {
        var child = stack.pop();
        if (child.isDirectory()) {
          var files = child.listFiles();
        
          for(var i = 0; i < files.length; i++) {
            var f = files[i];
            stack.push(f);
          }
        } else if (child.isFile()) {
          
          // remove the basedir
          var file = child.getPath();
          file = file.replace(basedir, basedirreplacement);
          
          // remove any leading file separater this is normally bad
          if (!"".equals(basedir) && file.startsWith("\\") || file.startsWith("/")) {
            file = file.substring(1);
          }
        
          csvFiles += "," + file;
        }
      }
      
      // remove any trailing comma
      if (!"".equals(csvFiles)) {
        csvFiles = csvFiles.substring(1);
      }
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(csvFiles);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileCombineFilesets" language="javascript">
    <attribute name="filesetid" />
    <element name="fileset" type="fileset" />
    
    <![CDATA[
      var filesetId = attributes.get("filesetid");
      var filesets = elements.get("fileset");
            
      // create the stuff we need
      var basedir = null;
      var files = new java.util.ArrayList();

      // check each file
      for (var i = 0; i < filesets.size(); ++i) {      
        var fileset = filesets.get(i);
        var fsBaseDir = fileset.getDir(project);
        
        if (basedir == null) {
          basedir = fsBaseDir;          
        } else if (basedir != null && !basedir.equals(fsBaseDir)) {
          throw new java.lang.IllegalArgumentException("The base directories of the filesets must match '" + basedir + "' != '" + fsBaseDir + "'");
        }
        
        // get the files of the set
        var fsScanner = fileset.getDirectoryScanner(project);
        var fsFiles = fsScanner.getIncludedFiles();
       
        // check each file
        for (j = 0; j < fsFiles.length; ++j) {
          var fileName = fsFiles[j];
          var file = new java.io.File(basedir, fileName);
          
          // add the file
          files.add(file);
        }
      }
      
      // create the new fileset
      if (basedir == null) {
        throw new java.lang.IllegalArgumentException("You have to past at least one fileset");
      } else {
        var fs = project.createDataType("fileset");
        fs.setDir(new java.io.File(basedir));
        
        // add the refered fileset
        project.addReference(filesetId, fs);

        // get the file relative to the basedir
        for (var i = 0; i < files.size(); ++i) {
          var file = files.get(i);
          var relativePath = basedir.toURI().relativize(file.toURI()).getPath();

          // add all the files relative to the basedir
          var inc = fs.createInclude();
          inc.setName(relativePath);
        }
      }
    ]]>
  </scriptdef>

  <scriptdef name="fileAppendSuffix" language="javascript">
    <attribute name="property" />
    <attribute name="file" />
    <attribute name="suffix" />
    
    <![CDATA[
      var property = attributes.get("property");
      var fileName = attributes.get("file");
      var suffix = attributes.get("suffix");
      
      var file = new java.io.File(fileName);
      var name = file.getName();
      var i = name.contains(".") ? name.lastIndexOf('.') : name.length();
      
      var modName = name.substring(0, i) + suffix + name.substring(i);
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(modName);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileReplaceName" language="javascript">
    <attribute name="property" />
    <attribute name="file" />
    <attribute name="renameTo" />
    
    <![CDATA[
      var property = attributes.get("property");
      var filePath = attributes.get("file");
      var renameTo = attributes.get("renameto");
      
      var file = new java.io.File(filePath);
      var parent = file.getParent();
      var newFile = new java.io.File(parent, renameTo);
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(newFile);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileGetCanonicalFile" language="javascript">
    <attribute name="file" />
    <attribute name="property" />
    
    <![CDATA[
      var property = attributes.get("property");
      var filePath = attributes.get("file");
      
      var file = new java.io.File(filePath);
      var cname = "";
      try {
        cname = file.getCanonicalPath();
      } catch (error) {
        cname = file.getAbsolutePath();
      }
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(cname);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileXmlEncoding" language="javascript">
    <attribute name="xmlFile" />
    <!-- optional -->
    <attribute name="property" />  <!-- default file.encoding -->
    <attribute name="default" />   <!-- default UTF-8 -->
    
    <![CDATA[
      var convert = function(val) {
        var conv = new java.lang.String.format("%02X", new java.lang.Integer(val));
        var convLength = conv.length();
        
        return convLength >= 2 ? conv.substring(conv.length() - 2) : convLength == 1 ? "0" + conv : "00";
      };
    
      var xmlFileName = attributes.get("xmlfile");
      var xmlFile = new java.io.File(xmlFileName);
      var property = attributes.containsKey("property") ? attributes.get("property") : "file.encoding";
      var defaultEncoding = attributes.containsKey("default") ? attributes.get("default") : "UTF-8";
      var inStream = null;
      
      try {
        inStream = new java.io.FileInputStream(xmlFile); 
      } catch (e) {
          e.printStackTrace();
      }
      
      var encoding = null;
      var readEncoding = false;
      
      var bufferContent = "";
      var bufferSize = 1000;
      for (var i = 0; i < bufferSize; i++) {
        bufferContent += "0";
      }
      var buffer = java.lang.String(bufferContent).getBytes();
      bufferSize = buffer.length;
      var read = inStream.read(buffer, 0, 4);

      // get the first four characters
      var firstSign = convert(buffer[0]);
      var secondSign = convert(buffer[1]); 
      var thirdSign = convert(buffer[2]); 
      var fourthSign = convert(buffer[3]); 
      
      // check the first characters
      if (firstSign == null) {
        // nothing to do
      } else if (firstSign.equals("00")) {

        if (secondSign.equals("00") && thirdSign.equals("FE") && fourthSign.equals("FF")) {
          encoding = "UTF_32BE";
        } else if (secondSign.equals("00") && thirdSign.equals("00") && fourthSign.equals("3C")) {
          encoding = "UTF_32BE";
          readEncoding = true;
        } else if (secondSign.equals("3C") && thirdSign.equals("00") && fourthSign.equals("3F")) {
          encoding = "UnicodeBigUnmarked";
          readEncoding = true;
        }
      } else if (firstSign.equals("FF")) {
        if (secondSign.equals("FE") && thirdSign.equals("00") && fourthSign.equals("00")) {
          encoding = "UTF_32LE";
        } else if (secondSign.equals("FE")) {
          encoding = "UnicodeLittleUnmarked";
        }
      } else if (firstSign.equals("3C")) {
        readEncoding = true;
        if (secondSign.equals("00") && thirdSign.equals("00") && fourthSign.equals("00")) {
          encoding = "UTF_32LE";
        } else if (secondSign.equals("00") && thirdSign.equals("3F") && fourthSign.equals("00")) {
          encoding = "UnicodeLittleUnmarked";
        } else if (secondSign.equals("3F") && thirdSign.equals("78") && fourthSign.equals("6D")) {
          encoding = "US-ASCII";
        }
      } else if (firstSign.equals("FE")) {
        if (secondSign.equals("FF")) {
          encoding = "UnicodeBigUnmarked";
        }
      } else if (firstSign.equals("EF")) {
        if (secondSign.equals("BB") && thirdSign.equals("BF")) {
          encoding = "UTF-8";
        }
      } else if (firstSign.equals("4C")) {
        if (secondSign.equals("6F") && thirdSign.equals("A7") && fourthSign.equals("94")) {
          encoding = "CP037";
        }
      }
            
      if (readEncoding) {
      
        // look for the word encoding in the first lines, maybe one is defined
        read = inStream.read(buffer, 4, bufferSize - 4);
        var cs = new java.nio.charset.Charset.forName("US-ASCII");
        var s = new java.lang.String(buffer, 0, read, cs);
        var pos = s.indexOf("encoding");
        
        // create the regular expression to search for encodings
        var regEx = "encoding\\s*\\=\\s*(?:\"([^\"]*)\"|'([^\']*)')";        
        var pattern = java.util.regex.Pattern.compile(regEx, java.util.regex.Pattern.DOTALL);
        var matcher = pattern.matcher(s);
        
        if (matcher.find()) {
          var encoding = matcher.group(1) == null ? matcher.group(2) : matcher.group(1);
        } else {          
          // check the file
          var getEncodingOfFile = project.createTask("fileEncoding");
          getEncodingOfFile.setDynamicAttribute("file", xmlFileName);
          getEncodingOfFile.setDynamicAttribute("property", property);
          getEncodingOfFile.execute();
          
          // get the defined encoding
          encoding = project.getProperty(property);
        }
      }
  
      // if we still don't know set the default
      if (encoding == null) {
        encoding = defaultEncoding;
      }
      
      // close the stream
      try {
        inStream.close(); 
      } catch (e) {
        // nothing
      }
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(encoding);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileEncoding" language="javascript">
    <attribute name="file" />
    <!-- optional -->
    <attribute name="property" />  <!-- default file.encoding -->
    <attribute name="default" />   <!-- default US-ASCII -->
    
    <![CDATA[    
      var file = new java.io.File(attributes.get("file"));
      var property = attributes.containsKey("property") ? attributes.get("property") : "file.encoding";
      var inStream = null;
      
      try {
        inStream = new java.io.FileInputStream(file); 
      } catch (e) {
          e.printStackTrace();
      }
      
      var encoding = null;
      
      var bufferContent = "";
      var bufferSize = 400;
      for (var i = 0; i < bufferSize; i++) {
        bufferContent += "0";
      }
      var buffer = java.lang.String(bufferContent).getBytes();
      bufferSize = buffer.length;
      
      // look for the word encoding in the first lines, maybe one is defined
      read = inStream.read(buffer, 0, bufferSize);
      encoding = "US-ASCII";
      
      // try to define the encoding by the content
      do {
        var d = java.nio.charset.Charset.forName("US-ASCII").newDecoder();
        try {
          var r = d.decode(java.nio.ByteBuffer.wrap(buffer));
          r.toString();
        } catch(e) {
        
          // let's use UTF-8 to be sure
          encoding = "UTF-8";
          break;
        }
        
        read = inStream.read(buffer, 0, bufferSize);
      } while (read != -1);
      
      // close the stream
      try {
        inStream.close(); 
      } catch (e) {
        // nothing
      }
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(encoding);
      setProperty.execute();
    ]]>
  </scriptdef>
</project>