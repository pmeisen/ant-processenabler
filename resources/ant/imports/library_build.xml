<!--
  Library which adds some macros and targets for build operations
  
  Created on: 01.03.2012
  Created by: Philipp Meisen <philipp@meisen.net>
  History:
    01.03.2012
      - Creation of library
  -->
<project name="library_build">
  <property name="build.library.version" value="2.1.0" description="The current version of the library" />
  <dirname property="library_build.basedir" file="${ant.file.library_build}"/>

  <property name="build.template.startBatch.generic" value="templateStart" description="The generic (cross-platform) name of the template file to start an application; i.e. generic means that this file without any extension is a unix-script and with a bat-extension is the windows script" />  
  <property name="build.template.startBatch.folder" location="${main.root}/app" description="The folder to look for the templates" />
  
  <property name="build.library.resfile.template.launcher" location="${main.root}/app/templateLauncher.properties" description="The file which defines the properties needed by the launcher to start; the file should use the placeholders defined in buildAssembly task" />
  <property name="build.library.resfile.template.startBatch.unix" location="${build.template.startBatch.folder}/${build.template.startBatch.generic}" description="Start script file to be executed (Unix)" />
  <property name="build.library.resfile.template.startBatch.windows" location="${build.template.startBatch.folder}/${build.template.startBatch.generic}.bat" description="Start batch file to be executed (Windows)" />
  <property name="build.library.resfile.maven.pomLauncher" location="${main.root}/app/pomLauncher.xml" description="The maven dependencies which define the launcher" />
    
  <property name="build.javac.source" value="1.6" description="Provide source compatibility with specified release" />
  <property name="build.javac.target" value="1.6" description="Generate class files for specific VM version" />
  <property name="build.debug" value="true" description="Indicates whether source should be compiled with debug information, will be ignored if a none-snapshot will be build" />
  
  <property name="build.project.resources.dir" value="resources" description="Project resources directory" />
  <property name="build.assembly.resources.dir" value="resources" description="Assembly resources directory" />
  <property name="build.library.dir" value="lib" description="Project library directory" />
  <property name="build.binary.dir" value="bin" description="Project binary directory" />
  <property name="build.javadoc.dir" value="javadoc" description="Project javadoc directory" />
  <property name="build.app.dir" value="app" description="Build directory for appliactions" />
  <property name="build.source.dir" value="src" description="Project source code directory" />
  <property name="build.build.dir" value="_build" description="Project build directory" />
  <property name="build.dir" location="${build.build.dir}" description="Project build directory (full path)" />
  <property name="build.tmpdir" location="${build.dir}/tmp" description="Project temporary code directory (full path)" />
  <property name="build.srcdir" location="${basedir}/${build.source.dir}" description="Project source code directory (full path)" />
  <property name="build.resourcedir" location="${basedir}/${build.project.resources.dir}" description="Project source code directory (full path)" />
  
  <property name="build.pack.default.excludes" value="**/*.java" description="Defines whatever has to be excluded from a jar by default" />
  <property name="build.package.excludes" value="" description="Defines the packages which are excluded when building, excluded packages will still be added to the sources" />
  <property name="build.applications.groupId" value="" description="The groupId used by applications (assemblies)" />
    
  <property name="build.launcher.create" value="true" description="Defines if a launcher should be created" />
  <property name="build.launcher.mainClass" value="" description="The main class started by the launcher" />
  <property name="build.launcher.groupId" value="net.meisen.general" description="The launcher groupId to be used" />
  <property name="build.launcher.artifactId" value="net-meisen-general-gen-launcher" description="The launcher artifactId to be used" />
  <property name="build.launcher.version" value="TRUNK-SNAPSHOT" description="The launcher version to be used" />
  <property name="build.launcher.cmdLineArgs" value="" description="additional command line arguments for the launcher" />
  <property name="build.launcher.jvmArgs" value="" description="additional JVM arguments for the launcher" />
  <property name="build.launcher.maxPermSize" value="256m" description="the maxPermSize value to be used by the launcher" />
  <property name="build.launcher.xmx" value="512M" description="The Xmx value to be used by the launcher" />
  <property name="build.launcher.resourcesDir" value="" description="the list of resource directories used by the launcher, the default resource dir (i.e. ${build.assembly.resources.dir}) will be appended" />
  <property name="build.launcher.libraryDir" value="" description="the list of libhrary directories used by the launcher, the default library dir (i.e. ${build.library.dir}) will be appended" />

  <property name="build.startbatch.filename.generic" value="start" description="The generic (cross-platform) name of the file to start an application" />  
  <property name="build.startbatch.create" value="true" description="Defines if a start batch file should be created, this property is always true if a launcher is created (i.e. if build.launcher.create is true, this setting is ignored)" />
  
  <property name="build.assembly.create" value="false" description="set this attribute to true to create an assembly of the project" />
  <property name="build.assembly.maven.type" value="zip" description="the type of the file created during assembling" />
  <property name="build.build.maven.type" value="jar" description="the type of the file created during building" />
  
  <property name="build.init" value="false" description="For internal usage only, please do not modify this property by a file" />
  
  <property name="build.resource.dependency" value="build.dependency" description="The resource type of a dependency" />
  <property name="build.resource.builtLibrary" value="build.result" description="The resource that has been built" />
  <property name="build.resource.resource" value="build.resource" description="The resource type of a resource" />
  
  <property name="build.release.scopes" value="compile" description="List of scopes which should be checked for SNAPSHOT dependencies" />
            
  <!--
    add the antcontrib library
    -->
  <taskdef resource="net/sf/antcontrib/antlib.xml" />

  <!--
    initialize - do some things that have to be done
    -->
  <if>
    <equals arg1="${build.init}" arg2="false" />
    <then>

      <!-- create the repository directory -->
      <mkdir dir="${build.dir}" />
      <mkdir dir="${build.tmpdir}" />

      <!-- reset the latest build -->
      <var name="build.appFile" value="" />
      <var name="build.appDir" value="" />
      <var name="build.binDir" value="" />
      <var name="build.javadocDir" value="" />
      <var name="build.buildFile" value="" />
      <var name="build.buildSrcFile" value="" />
      <var name="build.buildJavaDocFile" value="" />
      
      <!-- define if we build a snapshot or a release:
           - only the explicit call of an release target can enable release 
        -->
      <checkTarget property="build.tmp.releaseTarget" target="release" />
      <if>
        <equals arg1="${build.tmp.releaseTarget}" arg2="true" />
        <then>
          <echo level="info">The build is performed as RELEASE build</echo>
          <var name="build.type" value="release" />
        </then>
        <else>
          <echo level="info">The build is performed as SNAPSHOT build</echo>
          <var name="build.type" value="snapshot" />
        </else>
      </if>
      
      <!-- initialization finshed -->
      <var name="build.init" value="true" />
    </then>
  </if>
  
  
  <!--
    This task is used to remove all pre-builds. It should be called prior to <a href="#task_build">build</a> to avoid
    the creation of an incremental build, i.e. whenever a clean build should be created this task should be called.
      
    @fails 
      if the created builds cannot be deleted, i.e an io-error occurs

    @author Philipp Meisen
    @since 1.0.0
  -->
  <macrodef name="buildRemovePreBuilds">
    <sequential>
      <fileCleanUp dir="${build.dir}/${build.binary.dir}" recreate="false" />
    </sequential>
  </macrodef>
  
  <!--
    This task cleans up after the build process. It is part of the main cleanUp-target, which should
    be the last target of each call.
    
    @param complete
      set to 'true' to also remove all builds used for incremental builds 
      (i.e. the <a href="#task_buildRemovePreBuilds">buildRemovePreBuilds</a> is called),
      otherwise set to 'false'
    
    @fails 
      if one of the folders or files to be cleaned cannot be deleted

    @author Philipp Meisen
    @since 1.0.0
  -->
  <macrodef name="buildCleanUp">
    <attribute name="complete" default="false" />

    <sequential>
      <if>
        <or>
          <equals arg1="@{complete}" arg2="y" />
          <equals arg1="@{complete}" arg2="yes" />
          <equals arg1="@{complete}" arg2="true" />
        </or>
        <then>
          <buildRemovePreBuilds />
        </then>
      </if>

      <!-- cleanup a little -->
      <fileCleanUp dir="${build.tmpdir}" recreate="false" />
      
      <!-- reset the latest builds -->
      <var name="build.buildFile" value="" />
      <var name="build.appFile" value="" />
      <var name="build.appDir" value="" />
      <var name="build.binDir" value="" />
      <var name="build.javadocDir" value="" />
      <var name="build.buildSrcFile" value="" />
      <var name="build.buildJavaDocFile" value="" />  
    </sequential>
  </macrodef>

  <!--
    This task is used to build the current project, i.e. compile the source files using Java. The result of
    the build, i.e. the '.class'-files are created in the passed <i>dest</i>-folder. If no <i>dest</i>-folder is
    specified the build is to be a project build, which means that the property <i>build.binDir</i> will point
    to the location the files are created it.<br/>
    It is important to understand, that the property <i>build.binDir</i> will only be changed if no parameters 
    are passed, otherwise the task compiles the files without any semantical context.
    
    @param addExcludes 
      a comma-separated list of exclusion patterns, which specify additional sources to be 
      excluded from the compilation
    @param dest
      if this parameter is not specified (i.e. not listed or set to "") the task will build the project's
      sources and set the <i>build.binDir</i>, otherwise the sources will be build and the property won't 
      be changed
    @param cpfileset
      this parameter specifies the id of a fileset to be used as classpath for the build; if not specified
      the classpath will contain all the dependencies defined in the <i>pom</i>-file of the project (resolved
      using the <i>compile</i>-scope, i.e. the scopes <i>compile</i>, <i>system</i> and <i>provided</i> are included,
      further information can be retrieved at 
      <a href="http://maven.apache.org/ant-tasks/examples/dependencies.html" target="_blank">Maven Ant Tasks - Dependencies</a>
      under the section 'Filtering Dependencies by Scope')
    
    @fails 
      if the build fails, e.g. missing dependency, invalid code, ...

    @author Philipp Meisen
    @since 1.0.0
  -->
  <macrodef name="buildBuild">
    <attribute name="addExcludes" default="" />
    <attribute name="dest" default="" />
    <attribute name="cpfileset" default="" />
    
    <sequential>
      <!-- 
        check if a destination or classpath is defined, 
        if so the build won't be the latest build 
        -->
      <if>
        <and>
          <equals arg1="@{dest}" arg2="" />
          <equals arg1="@{cpfileset}" arg2="" />
        </and>
        <then>
          <var name="build.tmp.binDir" value="${build.dir}/${build.binary.dir}" />
          <var name="build.binDir" value="${build.tmp.binDir}" />
 
          <!-- get the dependencies for this build -->
          <mavenResolveDependencies fileset="build.tmp.classpath" scope="compile" />
          <var name="build.tmp.refid" value="build.tmp.classpath" />
        </then>
        <else>
          <var name="build.tmp.binDir" value="@{dest}" />
          <var name="build.tmp.refid" value="@{cpfileset}" />
        </else>
      </if>
      
      <!-- check if we build a debug version -->
      <if>
        <equals arg1="${build.type}" arg2="release" />
        <then>
          <var name="build.tmp.debug" value="false" />
        </then>
        <else>
          <var name="build.tmp.debug" value="${build.debug}" />
        </else>
      </if>
      
      <!-- check if there are sources -->
      <fileset dir="${build.srcdir}" id="build.tmp.sourceFileSet">
        <include name="**/*.java"/> 
      </fileset>
      <var name="build.tmp.sourcesSize" value="" unset="true" />
      <if><available file="${build.srcdir}"/><then><pathconvert refid="build.tmp.sourceFileSet" property="build.tmp.sourcesSize" setonempty="false"/></then></if>
      
      <if>
        <isset property="build.tmp.sourcesSize" />
        <then>

          <!-- transform the excludes -->
          <transformPackagesToPath property="build.tmp.srcExcludes" 
                                   packages="${build.package.excludes}" suffix="/**" packageSeparatore="/" separatore="," />

          <!-- compile the project -->
          <compile srcdir="${build.srcdir}" destdir="${build.tmp.binDir}" debug="${build.tmp.debug}" excludes="${build.tmp.srcExcludes},@{addExcludes}">
            <classpath>
              <fileset refid="${build.tmp.refid}" />
            </classpath>
          </compile>
        </then>
        <else>
          <fileCleanUp dir="${build.tmp.binDir}" />
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="compile">
    <attribute name="srcdir" />
    <attribute name="destdir" />
    <attribute name="debug" />
    <attribute name="includes" default="**/*.java" />
    <attribute name="excludes" />
  
    <element name="classpath" implicit="true" />
  
    <sequential>
         
      <!-- make sure the destination exists -->
      <mkdir dir="@{destdir}" />
    
      <!-- debug the compiler used -->
      <echo level="info">Compiling using the javac comiler</echo>
    
      <!-- compile -->
      <javac sourcepath="" srcdir="@{srcdir}" destdir="@{destdir}" debug="@{debug}" deprecation="true"
             includes="@{includes}" excludes="@{excludes}"
             includeantruntime="false" source="${build.javac.source}" target="${build.javac.target}">
        <classpath />

        <!-- 
          disable compiler warnings concerning untyped usage, e.g.:
          List a = new ArrayList() 
          -->
        <compilerarg value="-Xlint:unchecked"/>
      </javac>
    </sequential>
  </macrodef>
  
  <!--
    The <i>buildJavaDoc</i> task is used to create the JavaDoc of the source-files of the 
    project. The files are created in the javadoc-subdirectory (specified by the property 
    <a href="#property_build.javadoc.dir">build.javadoc.dir</a>), which is created in the
    build directory (specified by the property <a href="#property_build.dir">build.dir</a>).<br />
    The final creation can be retrieved via the property <i>build.javadocDir</i>, which
    is set by this task, i.e. if the property <i>build.javadocDir</i> is not set, this 
    task wasn't called.

    @param addClassPathFileSet 
      an id of a fileset which contains additional files to be added to the classpath
    @param addExcludes
      a comma-separated list of exclusion patterns, which specify additional sources to be 
      excluded from the documentation process

    @fails 
      if the creation of the JavaDoc fails

    @author Philipp Meisen
    @since 1.0.0
  -->
  <macrodef name="buildJavaDoc">
    <attribute name="addClassPathFileSet" default="" />
    <attribute name="addExcludes" default="" />
  
    <sequential>
      <if>
        <equals arg1="@{addClassPathFileSet}" arg2="" />
        <then>
          <fileset id="build.tmp.addClasspath" dir=".">
            <include name="this.file.should.never.exist"/> 
          </fileset>
          <var name="build.tmp.addClasspath" value="build.tmp.addClasspath" />
        </then>
        <else>
          <var name="build.tmp.addClasspath" value="@{addClassPathFileSet}" />
        </else>
      </if>
       
      <!-- set the directory -->
      <var name="build.javadocDir" value="${build.dir}/${build.javadoc.dir}" />
      <fileCleanUp dir="${build.javadocDir}" />

      <!-- check if there are sources -->
      <fileset dir="${build.srcdir}" id="build.tmp.sourceFileSet">
        <include name="**/*.java"/> 
      </fileset>
      <var name="build.tmp.sourcesSize" value="" unset="true" />
      <if><available file="${build.srcdir}"/><then><pathconvert refid="build.tmp.sourceFileSet" property="build.tmp.sourcesSize" setonempty="false"/></then></if>
      
      <if>
        <isset property="build.tmp.sourcesSize" />
        <then>
          <!-- get the dependencies for this build -->
          <mavenResolveDependencies fileset="build.tmp.classpath" scope="compile" />
        
          <!-- create the javadoc -->
          <transformPackagesToPath property="build.tmp.srcExcludes" 
                                   packages="${build.package.excludes}" suffix=".*" packageSeparatore="." separatore="," />
          <proxySetJavaArgsProperty property="build.tmp.argsProxy" argsPrefix="-J" />
          
          <javadoc packagenames="*"
                   sourcepath="${build.srcdir}"
                   defaultexcludes="yes"
                   excludepackagenames="${build.tmp.srcExcludes}"
                   destdir="${build.javadocDir}"
                   author="true"
                   version="true"
                   use="true"
                   verbose="false"
                   windowtitle="${maven.pom.name} ${maven.pom.version}"
                   additionalparam="${build.tmp.argsProxy}" >
            <doctitle><![CDATA[<h1>${maven.pom.name} ${maven.pom.version}</h1>]]></doctitle>
            <bottom><![CDATA[<i>Copyright &#169; ${NOW} ${main.vendor} - All Rights Reserved.</i>]]></bottom>
            <classpath>
              <fileset refid="build.tmp.classpath" />
              <fileset refid="${build.tmp.addClasspath}" />
            </classpath>
            
            <link href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.0/" />
          </javadoc>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <!-- determines the name of the resulting artifact -->
  <macrodef name="buildGetArtifactName">
    <attribute name="type" default="build" />   <!-- the type can be javadoc, src, app or build -->
    <attribute name="property" default="build.tmp.@{type}.artifact" />
    <attribute name="folder" default="${build.dir}" />
    
    <sequential>
      <mavenSetPom />
      
      <switch value="@{type}">
        <case value="build">
          <var name="build.tmp.artifactClassifier" value="" />
          <var name="build.tmp.artifactExtension" value="${build.build.maven.type}" />
        </case>
        <case value="app">
          <var name="build.tmp.artifactClassifier" value="${maven.attachment.app}" />
          <var name="build.tmp.artifactExtension" value="${build.assembly.maven.type}" />
        </case>
        <case value="src">
          <var name="build.tmp.artifactClassifier" value="${maven.attachment.sources}" />
          <var name="build.tmp.artifactExtension" value="jar" />
        </case>
        <case value="javadoc">
          <var name="build.tmp.artifactClassifier" value="${maven.attachment.javadoc}" />
          <var name="build.tmp.artifactExtension" value="jar" />
        </case>
        <default>
          <fail>Invalid type for buildGetArtifactName, please use build, javadoc, src or app</fail>
        </default>
      </switch>
      
      <!-- mark the classifier if there is one -->
      <if>
        <not><equals arg1="${build.tmp.artifactClassifier}" arg2="" /></not>
        <then>
          <var name="build.tmp.artifactClassifier" value="-${build.tmp.artifactClassifier}" />
        </then>
      </if>
      
      <!-- mark the extension if there is one -->
      <if>
        <not><equals arg1="${build.tmp.artifactExtension}" arg2="" /></not>
        <then>
          <var name="build.tmp.artifactExtension" value=".${build.tmp.artifactExtension}" />
        </then>
      </if>
      
      <var name="@{property}" value="" unset="true" />
      <property name="@{property}" location="@{folder}/${maven.pom.artifactId}-${maven.pom.version}${build.tmp.artifactClassifier}${build.tmp.artifactExtension}" />
    </sequential>
  </macrodef>
  
  <!--
    buildPack - wraps the bin directory in build in a jar
    -->
  <macrodef name="buildPack">
    <attribute name="addExcludes" default="" />
    <attribute name="src" default="" />
    <attribute name="dest" default="" />
    
    <sequential>

      <!-- make sure we have something to pack -->
      <if>
        <and>
          <equals arg1="@{src}" arg2="" />
          <equals arg1="${build.binDir}" arg2="" />
          <not><isset property="build.binDir" /></not>
        </and>
        <then>
          <fail>No latest binaries found, the classes cannot be packed</fail>
        </then>
        <elseif>
          <equals arg1="@{src}" arg2="" />
          <then>
            <var name="build.tmp.src" value="${build.binDir}" />
          </then>
        </elseif>
        <else>
          <var name="build.tmp.src" value="@{src}" />
        </else>
      </if>
    
      <!-- get the name -->
      <if>
        <and>
          <equals arg1="${build.tmp.src}" arg2="${build.binDir}" />
          <equals arg1="@{dest}" arg2="" />
        </and>
        <then>

          <!-- get the pom settings -->
          <mavenSetPom />
          
          <var name="build.tmp.buildFile" value="${build.dir}/${maven.pom.artifactId}-${maven.pom.version}.jar" />
          <var name="build.buildFile" value="${build.tmp.buildFile}" />
        </then>
        <else>
          <var name="build.tmp.buildFile" value="@{dest}" />
        </else>
      </if>

      <!-- check the files which are forced to be included -->
      <transformPackagesToPath property="build.tmp.includeSources" 
                               packages="${build.package.includeSources}" suffix="/**" packageSeparatore="/" separatore="," />
      
      <!-- wrap the bin directory -->
      <transformPackagesToPath property="build.tmp.srcExcludes" 
                               packages="${build.package.excludes}" suffix="/**" packageSeparatore="/" separatore="," />

      <!-- check if sources are available -->
      <if>
        <available file="${build.srcdir}" />
        <then>
          <jar destfile="${build.tmp.buildFile}" basedir="${build.tmp.src}">
         
            <!-- add the resources -->
            <fileset dir="${build.srcdir}" excludes="${build.pack.default.excludes},${build.tmp.srcExcludes},@{addExcludes}" />
            <fileset dir="${build.srcdir}" includes="${build.tmp.includeSources}" />
            
            <!-- write the manifest -->
            <manifest>
              <attribute name="Built-By" value="${user.name}" />
              <attribute name="Built-Date" value="${NOW}" />
              
              <attribute name="Implementation-Vendor" value="${main.vendor}" />
              <attribute name="Implementation-Title" value="${maven.pom.name}" />
              <attribute name="Implementation-Version" value="${maven.pom.version}" />
              
              <attribute name="SVN-Revision" value="${svn.info.lastRev}" />          
            </manifest>
          </jar>
        </then>
        <else>
          <jar destfile="${build.tmp.buildFile}" basedir="${build.tmp.src}">
            
            <!-- write the manifest -->
            <manifest>
              <attribute name="Built-By" value="${user.name}" />
              <attribute name="Built-Date" value="${NOW}" />
              
              <attribute name="Implementation-Vendor" value="${main.vendor}" />
              <attribute name="Implementation-Title" value="${maven.pom.name}" />
              <attribute name="Implementation-Version" value="${maven.pom.version}" />
              
              <attribute name="SVN-Revision" value="${svn.info.lastRev}" />          
            </manifest>
          </jar>
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <!--
    buildPackSource - wraps the src directory in a jar
    -->
  <macrodef name="buildPackSource">
    <attribute name="excludesPattern" default="" />
    
    <sequential>
    
      <!-- get the pom settings -->
      <mavenSetPom />
    
      <!-- set the jar files -->
      <buildGetArtifactName property="build.buildSrcFile" type="src" />
      
      <!-- wrap the src directory -->
      <if>
        <available file="${build.srcdir}" />
        <then>
          <jar destfile="${build.buildSrcFile}" basedir="${build.srcdir}">

            <!-- write the manifest -->
            <manifest>
              <attribute name="Built-By" value="${user.name}" />
              <attribute name="Built-Date" value="${NOW}" />
              
              <attribute name="Implementation-Vendor" value="${main.vendor}" />
              <attribute name="Implementation-Title" value="${maven.pom.name} (${maven.attachment.sources})" />
              <attribute name="Implementation-Version" value="${maven.pom.version}" />
              
              <attribute name="SVN-Revision" value="${svn.info.lastRev}" /> 
            </manifest>
          </jar>
        </then>
        <else>
          <jar destfile="${build.buildSrcFile}" basedir="${basedir}" excludes="**/*">

            <!-- write the manifest -->
            <manifest>
              <attribute name="Built-By" value="${user.name}" />
              <attribute name="Built-Date" value="${NOW}" />
              
              <attribute name="Implementation-Vendor" value="${main.vendor}" />
              <attribute name="Implementation-Title" value="${maven.pom.name} (${maven.attachment.sources})" />
              <attribute name="Implementation-Version" value="${maven.pom.version}" />
              
              <attribute name="SVN-Revision" value="${svn.info.lastRev}" /> 
            </manifest>
          </jar>
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <!--
    buildPackJavaDoc - wraps the JavaDoc directory in a jar
    -->
  <macrodef name="buildPackJavaDoc">   
    <sequential>
      <!-- make sure we have something to pack -->
      <if>
        <or>
          <not><isset property="build.javadocDir"/></not>
          <equals arg1="${build.javadocDir}" arg2="" />
        </or>
        <then>
          <fail>No latest JavaDoc found, the JavaDoc cannot be packed</fail>
        </then>
      </if>
    
      <!-- get the pom settings -->
      <mavenSetPom />
    
      <!-- set the jar files -->
      <buildGetArtifactName property="build.buildJavaDocFile" type="javadoc" />

      <!-- wrap the javadoc directory -->
      <jar destfile="${build.buildJavaDocFile}" basedir="${build.javadocDir}">
        
        <!-- write the manifest -->
        <manifest>
          <attribute name="Built-By" value="${user.name}" />
          <attribute name="Built-Date" value="${NOW}" />
          
          <attribute name="Implementation-Vendor" value="${main.vendor}" />
          <attribute name="Implementation-Title" value="${maven.pom.name} (${maven.attachment.javadoc})" />
          <attribute name="Implementation-Version" value="${maven.pom.version}" />
          
          <attribute name="SVN-Revision" value="${svn.info.lastRev}" /> 
        </manifest>
      </jar>

    </sequential>
  </macrodef>
    
  <macrodef name="buildAppendManifest">
    <attribute name="jar" default="" />
    <attribute name="name" />
    <attribute name="value" />
    
    <sequential>
      <if>
        <equals arg1="@{jar}" arg2="" />
        <then>
        
          <!-- check the buildFile, before its used -->
          <if>
            <or>
              <not><isset property="build.buildFile"/></not>
              <equals arg1="${build.buildFile}" arg2="" />
            </or>
            <then>
              <fail>No latest build found, nothing is installed</fail>
            </then>
          </if>
        
          <var name="build.tmp.manifest" value="${build.buildFile}" />
        </then>
        <else>
          <var name="build.tmp.manifest" value="@{jar}" />
        </else>
      </if>
      
      <!-- create a folder to be used for output -->
      <fileCleanUp dir="${build.tmpdir}" />
      
      <!-- get the file -->
      <unjar src="${build.tmp.manifest}" dest="${build.tmpdir}" />

      <!-- modify the file -->
      <manifest file="${build.tmpdir}/META-INF/MANIFEST.MF" mode="update">
        <attribute name="@{name}" value="@{value}"/>
      </manifest>
      
      <!-- add the file again -->
      <jar destfile="${build.tmp.manifest}" basedir="${build.tmpdir}" manifest="${build.tmpdir}/META-INF/MANIFEST.MF" />
    </sequential>
  </macrodef>
  
  <!--
    buildInstallLatestBuild - installes the latest build to the local repository
    -->
  <macrodef name="buildInstallLatestBuild">
    <sequential>
      <if>
        <or>
          <not><isset property="build.buildFile"/></not>
          <equals arg1="${build.buildFile}" arg2="" />
          <not><isset property="build.buildSrcFile"/></not>
          <equals arg1="${build.buildSrcFile}" arg2="" />
          <not><isset property="build.buildJavaDocFile"/></not>
          <equals arg1="${build.buildJavaDocFile}" arg2="" />
        </or>
        <then>
          <fail>No latest build found, nothing is installed</fail>
        </then>
        <else>
          <mavenInstall file="${build.buildFile}" />
          <mavenInstallAttachment file="${build.buildSrcFile}" classifier="${maven.attachment.sources}" />
          <mavenInstallAttachment file="${build.buildJavaDocFile}" classifier="${maven.attachment.javadoc}" />
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <!--
    buildDeployLatestBuild - deploys the latest build to the responsible repository
    -->
  <macrodef name="buildDeployLatestBuild">
    <sequential>
      <if>
        <or>
          <not><isset property="build.buildFile"/></not>
          <equals arg1="${build.buildFile}" arg2="" />
        </or>
        <then>
          <fail>No latest build found, nothing is deployed</fail>
        </then>
        <else>
          <mavenDeploy file="${build.buildFile}" />
        </else>
      </if>
      
      <!-- deploy the sources if the exist -->
      <if>
        <and>
          <isset property="build.buildSrcFile"/>
          <not><equals arg1="${build.buildSrcFile}" arg2="" /></not>
        </and>
        <then>
          <mavenDeployAttachment file="${build.buildSrcFile}" classifier="${maven.attachment.sources}" />
        </then>
      </if>
      
      <!-- deploy the javadoc if the exist -->
      <if>
        <and>
          <isset property="build.buildJavaDocFile"/>
          <not><equals arg1="${build.buildJavaDocFile}" arg2="" /></not>
        </and>
        <then>
          <mavenDeployAttachment file="${build.buildJavaDocFile}" classifier="${maven.attachment.javadoc}" />
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <!--
    buildAssembly - assembles the application by adding dependencies and a launcher
    -->
  <macrodef name="buildAssembly">
    <attribute name="mainClass" default="${build.launcher.mainClass}" />
    <attribute name="templateLauncher" default="${build.library.resfile.template.launcher}" />
    <attribute name="templateGenericStartBatch" default="${build.template.startBatch.folder}/${build.template.startBatch.generic}" />
    <attribute name="launcherPropertiesName" default="launcher.properties" />
    <attribute name="startGenericStartBatchName" default="${build.startbatch.filename.generic}" />
  
    <sequential>
    
      <!-- make sure we have a build -->
      <if>
        <not><equals arg1="${build.assembly.create}" arg2="true" /></not>
        <then>
          <fail>You must set the build.assembly.create attribute to true so that the project can be assembled</fail>
        </then>
        <elseif>
          <and>
            <equals arg1="@{mainClass}" arg2="" />
            <or>
              <equals arg1="${build.launcher.create}" arg2="y" />
              <equals arg1="${build.launcher.create}" arg2="yes" />
              <equals arg1="${build.launcher.create}" arg2="true" />
            </or>
          </and>
          <then>
            <fail>No main-class (build.launcher.create property) specified for application assembly</fail>
          </then>
        </elseif>
        <elseif>
          <or>
            <not><isset property="build.buildFile"/></not>
            <equals arg1="${build.buildFile}" arg2="" />
          </or>
          <then>
            <fail>No latest build found, the application cannot be assembled</fail>
          </then>
        </elseif>
      </if>
    
      <!-- the directory the app should be assembled to -->
      <var name="build.tmp.appFolder" value="${build.dir}/${build.app.dir}" />
      <fileCleanUp dir="${build.tmp.appFolder}" recreate="true" />
          
      <!-- get the dependencies of the application -->
      <mavenResolveDependencies fileset="build.tmp.appLibs" scope="runtime" pomid="build.tmp.pomAssembly" />
      
      <!-- copy the dependent files -->
      <fileCallMacroForEach macro="buildMoveResource" parameters="resourceType=[[${build.resource.dependency}]];rootFolder=[[${build.tmp.appFolder}]];defaultLocation=[[${build.library.dir}]]">
        <fileset refid="build.tmp.appLibs" />
      </fileCallMacroForEach>
      <fileCallMacroForEach macro="buildMoveResource" parameters="resourceType=[[${build.resource.builtLibrary}]];rootFolder=[[${build.tmp.appFolder}]];defaultLocation=[[${build.library.dir}]]">
        <fileset file="${build.buildFile}" />
      </fileCallMacroForEach>

      <!-- copy the resources files -->
      <fileCallMacroForEach macro="buildMoveResource" parameters="resourceType=[[${build.resource.resource}]];rootFolder=[[${build.tmp.appFolder}]];defaultLocation=[[${build.assembly.resources.dir}]]">
        <fileset dir="${build.resourcedir}" />
      </fileCallMacroForEach>


      <!-- set up a launcher if we have a main file and if it should be done -->
      <if>
        <or>
          <equals arg1="${build.launcher.create}" arg2="y" />
          <equals arg1="${build.launcher.create}" arg2="yes" />
          <equals arg1="${build.launcher.create}" arg2="true" />
        </or>
        <then>
      
          <!-- get the dependencies of the launcher -->
          <mavenResolveDependencies fileset="build.tmp.launcherLibs" scope="runtime" 
                                    pomid="build.tmp.pomLauncher" pomfile="${build.library.resfile.maven.pomLauncher}" />
        
          <!-- copy the dependent files -->
          <copy todir="${build.tmp.appFolder}/launcher">
            <fileset refid="build.tmp.launcherLibs" />
            <mapper type="flatten" />
          </copy>
          
          <!-- get the needed values for replacing -->
          <var name="build.tmp.launcherJarPath" value="launcher/${build.launcher.artifactId}-${build.launcher.version}.jar" />
          <var name="build.tmp.mainClass" value="@{mainClass}" />
          <var name="build.tmp.launcherProperties" value="launcher/@{launcherPropertiesName}" />
          <var name="build.tmp.cmdLineArgs" value="${build.launcher.cmdLineArgs}" />
          
          <!-- get the JVM args -->
          <if>
            <and>
              <contains string="${build.launcher.jvmArgs}" substring="-XX:MaxPermSize=" casesensitive="false" />
              <contains string="${build.launcher.jvmArgs}" substring="-Xmx" casesensitive="false" />
            </and>
            <then>
              <echo level="warn">Instead of passing the -XX:MaxPermSize and -Xmx via the jvmArgs use the build.launcher.maxPermSize and build.launcher.xmx properties</echo>
              <var name="build.tmp.jvmArgs" value="${build.launcher.jvmArgs}" />
            </then>
            <elseif>
              <contains string="${build.launcher.jvmArgs}" substring="-XX:MaxPermSize=" casesensitive="false" />
              <then>
                <echo level="warn">Instead of passing the -XX:MaxPermSize via the jvmArgs use the build.launcher.maxPermSize property</echo>
                <var name="build.tmp.jvmArgs" value="${build.launcher.jvmArgs} -Xmx${build.launcher.xmx}" />
              </then>
            </elseif>
            <elseif>
              <contains string="${build.launcher.jvmArgs}" substring="-Xmx" casesensitive="false" />
              <then>
                <echo level="warn">Instead of passing the -Xmx via the jvmArgs use the build.launcher.xmx property</echo>
                <var name="build.tmp.jvmArgs" value="${build.launcher.jvmArgs} -XX:MaxPermSize=${build.launcher.maxPermSize}" />
              </then>
            </elseif>
            <else><var name="build.tmp.jvmArgs" value="${build.launcher.jvmArgs} -XX:MaxPermSize=${build.launcher.maxPermSize} -Xmx${build.launcher.xmx}" /></else>
          </if>
               
          <!-- set up the directories -->
          <createList property="build.tmp.launcher.resourcesDir" list="${build.launcher.resourcesDir}" value="${build.assembly.resources.dir}" separatore=";" />
          <createList property="build.tmp.launcher.libraryDir" list="${build.launcher.libraryDir}" value="${build.library.dir}" separatore=";" />
          <var name="build.tmp.classPaths" value="${build.tmp.launcher.resourcesDir}" />
          <var name="build.tmp.libPaths" value="${build.tmp.launcher.libraryDir}" />

          <!-- copy the files -->
          <fileReplaceAllProperties file="@{templateLauncher}" destFile="${build.tmp.appFolder}/launcher/@{launcherPropertiesName}" force="true" />
          <fileReplaceAllProperties file="@{templateGenericStartBatch}" destFile="${build.tmp.appFolder}/@{startGenericStartBatchName}" force="true" />
          <fileReplaceAllProperties file="@{templateGenericStartBatch}" destFile="${build.tmp.appFolder}/@{startGenericStartBatchName}.sh" force="true" />
          <fileReplaceAllProperties file="@{templateGenericStartBatch}.bat" destFile="${build.tmp.appFolder}/@{startGenericStartBatchName}.bat" force="true" />
        </then>
        
        <!-- its possible to create only a batch file of a template, so lets check if that should be done -->
        <elseif>
          <or>
            <equals arg1="${build.startbatch.create}" arg2="y" />
            <equals arg1="${build.startbatch.create}" arg2="yes" />
            <equals arg1="${build.startbatch.create}" arg2="true" />
          </or>
          <then>
          
            <!-- set up the directories -->
            <createList property="build.tmp.launcher.resourcesDir" list="${build.launcher.resourcesDir}" value="${build.assembly.resources.dir}" separatore=";" />
            <createList property="build.tmp.launcher.libraryDir" list="${build.launcher.libraryDir}" value="${build.library.dir}" separatore=";" />
            <var name="build.tmp.classPaths" value="${build.tmp.launcher.resourcesDir}" />
            <var name="build.tmp.libPaths" value="${build.tmp.launcher.libraryDir}" />

            <!-- copy the files -->
            <fileReplaceAllProperties file="@{templateGenericStartBatch}" destFile="${build.tmp.appFolder}/@{startGenericStartBatchName}" force="true" />
            <fileReplaceAllProperties file="@{templateGenericStartBatch}" destFile="${build.tmp.appFolder}/@{startGenericStartBatchName}.sh" force="true" />
            <fileReplaceAllProperties file="@{templateGenericStartBatch}.bat" destFile="${build.tmp.appFolder}/@{startGenericStartBatchName}.bat" force="true" />
          </then>
        </elseif>
      </if>
      
      <!-- set that we have a app -->
      <var name="build.appDir" value="${build.tmp.appFolder}" />
    </sequential>
  </macrodef>
  
  <macrodef name="buildMoveResource">
    <attribute name="resource" />
    <attribute name="resourceType" />
    <attribute name="rootFolder" />
    <attribute name="defaultLocation" default="" />
    <attribute name="defaultClean" default="false" />
    <attribute name="basedir" default="" />
    
    <sequential>
      <setLogLevel loglevel="warn" />
    
      <!-- reset the properties of the mapper -->
      <var name="resMapper.location" value="" unset="true"/>
      <var name="resMapper.rename" value="" unset="true"/>
      <var name="resMapper.unzip" value="" unset="true"/>
      <var name="resMapper.clean" value="" unset="true"/>
      <var name="resMapper.removePrior" value="" unset="true"/>
      <var name="resMapper.removeAfter" value="" unset="true"/>
      <var name="resMapper.excludeFiles" value="" unset="true"/>
      <var name="resMapper.flatten" value="" unset="true"/>
      <var name="resMapper.overwrite" value="" unset="true"/>
      <var name="resMapper.replaceProperties" value="" unset="true"/>
      <var name="resMapper.placeInJar" value="" unset="true"/>
      <var name="resMapper.removeFromFolderStructure" value="" unset="true"/>
      <var name="resMapper.doAutoInJar" value="" unset="true"/>
      <var name="resMapper.skip" value="" unset="true"/>
      
      <!-- set some properties which can be used by the resourceMapper instance to set values -->
      <var name="resMapper.rootFolder" value="@{rootFolder}" />

      <!-- get the file information -->
      <fileInfo file="@{resource}" />
      
      <!-- set the basedir if we don't have one -->
      <if>
        <equals arg1="@{basedir}" arg2="" />
        <then><var name="fileInfo.basedir" value="${fileInfo.directory}" /></then>
        <else><var name="fileInfo.basedir" value="@{basedir}" /></else>
      </if>
      
      <!-- get the new location -->
      <resourceMapper resourceFolder="${fileInfo.directory}" resource="@{resource}" resourceFileName="${fileInfo.name}" resourceType="@{resourceType}" />

      <!-- check if a skip is specified -->
      <if>
        <not><isset property="resMapper.skip" /></not>
        <then>
          <var name="resMapper.skip" value="false" />
        </then>
      </if>
      
      <!-- check if a location is specified -->
      <if>
        <not><isset property="resMapper.location" /></not>
        <then>
          <var name="resMapper.location" value="@{defaultLocation}" />
        </then>
      </if>
      
      <!-- check if a file should be renamed -->
      <if>
        <not><isset property="resMapper.rename" /></not>
        <then>
          <var name="resMapper.rename" value="${fileInfo.name}" />
        </then>
      </if>
      
      <!-- check if a file should be unzipped -->
      <if>
        <or>
          <not><isset property="resMapper.unzip" /></not>
          <and>
            <not><equals arg1="${fileInfo.extension}" arg2="zip" /></not>
            <not><equals arg1="${fileInfo.extension}" arg2="jar" /></not>
            <not><equals arg1="${fileInfo.extension}" arg2="rar" /></not>
          </and>
        </or>
        <then>        
          <var name="resMapper.unzip" value="false" />
        </then>
      </if>
      
      <!-- check if clean is specified, i.e. a folder should be emptied before items are copied there -->
      <if>
        <not><isset property="resMapper.clean" /></not>
        <then>
          <var name="resMapper.clean" value="@{defaultClean}" />
        </then>
      </if>
      
      <!-- check if removePrior is specified, i.e. a pattern which deletes specific files prior to the execution -->
      <if>
        <not><isset property="resMapper.removePrior" /></not>
        <then>
          <var name="resMapper.removePrior" value="" />
        </then>
      </if>
      
      <!-- check if removeAfter is specified, i.e. a pattern which deletes specific files after the execution -->
      <if>
        <not><isset property="resMapper.removeAfter" /></not>
        <then>
          <var name="resMapper.removeAfter" value="" />
        </then>
      </if>
      
      <!-- check if excludeFiles is specified, i.e. a pattern which is applied when files are copied or unzipped -->
      <if>
        <not><isset property="resMapper.excludeFiles" /></not>
        <then>
          <var name="resMapper.excludeFiles" value="" />
        </then>
      </if>
      
      <!-- check if flatten is specified, i.e. a any folder structure is removed when copying a file (files only!) -->
      <if>
        <not><isset property="resMapper.flatten" /></not>
        <then>
        
          <!-- depends on the type -->
          <if>
            <equals arg1="@{resourceType}" arg2="${build.resource.resource}" />
            <then>
              <var name="resMapper.flatten" value="false" />
            </then>
            <else>
              <var name="resMapper.flatten" value="true" />
            </else>
          </if>
        </then>
      </if>
      
      <!-- check if replaceProperties is specified, i.e. a any folder structure is removed when copying a file (files only!) -->
      <if>
        <not><isset property="resMapper.replaceProperties" /></not>
        <then>
          <var name="resMapper.replaceProperties" value="false" />
        </then>
      </if>
      
      <!-- check if we should remove any folderstructure default is empty i.e. nothing is removed -->
      <if>
        <not><isset property="resMapper.removeFromFolderStructure" /></not>
        <then>
          <var name="resMapper.removeFromFolderStructure" value="" />
        </then>
      </if>
      
      <!-- check if overwrite is specified, per default everything is overwritten, but if not we have to add some special excludes -->
      <if>
        <not><isset property="resMapper.overwrite" /></not>
        <then>
          <var name="resMapper.overwrite" value="true" />
        </then>
      </if>
      
      <!-- set the default for doAutoInJar -->
      <if>
        <not><isset property="resMapper.doAutoInJar" /></not>
        <then>
          <var name="resMapper.doAutoInJar" value="true" />
        </then>
      </if>

      <!-- check if we have a replacement in a jar which is done automatically if .jar folder is used on the classpath -->
      <if>
        <and>
          <equals arg1="${resMapper.doAutoInJar}" arg2="true" />
          <equals arg1="@{resourceType}" arg2="${build.resource.resource}" />
          <equals arg1="${fileInfo.exist}" arg2="true" />
          <equals arg1="${fileInfo.dir}" arg2="false" />
          <matches pattern=".*[\\/]\.jar(?:|(?:[\\/].*))" string="${fileInfo.directory}" />
        </and>
        <then>

          <!-- determine the jar -->
          <var name="build.tmp.jarFile" value="" unset="true"/>
          <propertyregex property="build.tmp.jarFile" input="${fileInfo.directory}" regexp=".*[\\/]\.jar[\\/]([^\\/]+\.jar)(?:|(?:[\\/].*))" select="\1" casesensitive="false" />

          <if>
            <isset property="build.tmp.jarFile" />
            <then>
              <echo level="debug">The file '${fileInfo.name}' will be moved into the jar ${build.tmp.jarFile}</echo>
              
              <var name="resMapper.location" value="" />
              <var name="resMapper.flatten" value="false" />
              <var name="resMapper.placeInJar" value="${build.tmp.jarFile}" />
              <var name="resMapper.removeFromFolderStructure" value=".jar/${build.tmp.jarFile}" />
            </then>
            <else>
              <echo level="warn">The file '${fileInfo.name}' cannot be moved in any jar, because no jar is specified</echo>
              <var name="resMapper.skip" value="true" />
            </else>
          </if>
        </then>
      </if>

      <!-- execute prior -->
      <if>
        <and>
          <not><equals arg1="${resMapper.removePrior}" arg2="" /></not>
          <equals arg1="${fileInfo.exist}" arg2="true" />
        </and>
        <then>
          <echo level="info">Mapper cleans '@{rootFolder}/${resMapper.location}' prior to mapping using pattern '${resMapper.removeAfter}'</echo>

          <fileCleanUp includeEmptyDirs="true">
            <fileset dir="@{rootFolder}/${resMapper.location}" includes="${resMapper.removePrior}"/>
          </fileCleanUp>
        </then>
      </if>

      <!-- execute mapping -->
      <if>
        <!-- skip if wished -->
        <equals arg1="${resMapper.skip}" arg2="true" />
        <then></then>
        
        <!-- we have a directory -->
        <elseif>
          <or>
            <!-- we have something to unzip -->
            <and>
              <equals arg1="${resMapper.unzip}" arg2="true" />
              <equals arg1="${fileInfo.exist}" arg2="true" />
              <equals arg1="${fileInfo.dir}" arg2="false" />
            </and>
          
            <!-- we have a directory -->
            <and>
              <equals arg1="${fileInfo.exist}" arg2="true" />
              <equals arg1="${fileInfo.dir}" arg2="true" />
            </and>
          </or>
          <then>
            <if>
              <equals arg1="${resMapper.unzip}" arg2="true" />
              
              <!-- unzip the files into a temporary directory -->
              <then>
                <fileCleanUp dir="${build.tmpdir}" />
                
                <!-- unzip the files -->
                <unzip src="@{resource}" dest="${build.tmpdir}" overwrite="true">
                  <patternset excludes="${resMapper.excludeFiles}" />
                </unzip>
                
                <var name="build.tmp.folder" value="${build.tmpdir}" />
                <var name="build.tmp.basedir" value="${build.tmpdir}" />
              </then>
              
              <!-- just use the directory specified -->
              <else>
                <var name="build.tmp.folder" value="@{resource}" />
                <var name="build.tmp.basedir" value="${fileInfo.basedir}" />
              </else>
            </if>
            
            <!-- check if the destination should be cleaned -->
            <if>
              <equals arg1="${resMapper.clean}" arg2="true" />
              <then>
                <echo level="info">Mapper cleans location: @{rootFolder}/${resMapper.location}</echo>
                <fileCleanUp dir="@{rootFolder}/${resMapper.location}" recreate="true" />
              </then>
            </if>
            
            <!-- handle file by file -->
            <for param="file">
              <path><fileset dir="${build.tmp.folder}" excludes="${resMapper.excludeFiles}" /></path>
              <sequential>
                <fileGetSubPath basedir="${build.tmp.basedir}" file="@{file}" property="build.tmp.subdir" removePrefix="${resMapper.removeFromFolderStructure}" />
                <fileInfo file="@{file}" propertyPrefix="build.tmp.folderFile" />
                <var name="build.tmp.file" value="@{rootFolder}/${resMapper.location}/${build.tmp.subdir}/${build.tmp.folderFile.name}" />

                <if>
                  <and>
                    <equals arg1="${resMapper.overwrite}" arg2="false" />
                    <available file="${build.tmp.file}" />
                  </and>
                  
                  <!-- do nothing it's like skipping -->
                  <then></then>
                  
                  <!-- replace the properties in the file -->
                  <elseif>
                    <equals arg1="${resMapper.replaceProperties}" arg2="true" />
                    <then>
                      <fileReplaceAllProperties file="@{file}" destFile="${build.tmp.file}" />
                    </then>
                  </elseif>
                  <!-- handle the file normally -->
                  <else>
                    <copy file="@{file}" tofile="${build.tmp.file}" failonerror="false" overwrite="true" />
                  </else>
                </if>
              </sequential>
            </for>
          </then>
        </elseif>
        
         <!-- we have a file -->
        <elseif>
          <and>
            <equals arg1="${fileInfo.exist}" arg2="true" />
            <equals arg1="${fileInfo.dir}" arg2="false" />
          </and>
          <then>
          
            <!-- determine the new destination of the file -->
            <if>
              <or>
                <not><isset property="resMapper.flatten" /></not>
                <equals arg1="${resMapper.flatten}" arg2="true" />
              </or>
              <then>
                <var name="build.tmp.destResource" value="${resMapper.location}/${resMapper.rename}" />
              </then>
              <!-- we don't want to flatten so copy with keeping the relative path -->
              <else>
                <fileGetSubPath basedir="${fileInfo.basedir}" file="@{resource}" property="build.tmp.subdir" removePrefix="${resMapper.removeFromFolderStructure}" />
                <var name="build.tmp.destResource" value="${resMapper.location}/${build.tmp.subdir}/${resMapper.rename}" />
              </else>
            </if>
            
            <!-- define the base directory for the process -->
            <if>
              <isset property="resMapper.placeInJar" />
              <then>
                <fileCleanUp dir="${build.tmpdir}" />
                <var name="build.tmp.destBaseFolder" value="${build.tmpdir}" />
              </then>
              <else>
                <var name="build.tmp.destBaseFolder" value="@{rootFolder}" />
              </else>
            </if>
            
            <!-- check if the file exists and if we are allowed to override -->
            <if>
            
              <!-- do nothing it's like skipping -->
              <and>
                <equals arg1="${resMapper.overwrite}" arg2="false" />
                <available file="${build.tmp.destBaseFolder}/${build.tmp.destResource}" />
              </and>
              <then>
              </then>
              
              <!-- handle the simple file -->
              <else>

                <!-- copy the file and replace properties if needed -->
                <if>
                  <equals arg1="${resMapper.replaceProperties}" arg2="true" />
                  <then>
                    <fileReplaceAllProperties file="@{resource}" destFile="${build.tmp.destBaseFolder}/${build.tmp.destResource}" />
                  </then>
                  <!-- we don't replace any properties -->
                  <else>
                    <copy file="@{resource}" preservelastmodified="true" tofile="${build.tmp.destBaseFolder}/${build.tmp.destResource}" failonerror="false" overwrite="true" />
                  </else>
                </if>
                
                <!-- check if we should really move the file into a jar -->
                <if>
                  <isset property="resMapper.placeInJar" />
                  <then>
                    <!-- create the modified jar name -->
                    <fileAppendSuffix property="build.tmp.modFileName" file="${resMapper.placeInJar}" suffix="-${maven.attachment.modified}" />
                  
                    <fileset id="build.tmp.possibleModifiedJars" dir="@{rootFolder}" includes="**/${build.tmp.modFileName}" />
                    <fileset id="build.tmp.possibleJars" dir="@{rootFolder}" includes="**/${resMapper.placeInJar}" />
                    
                    <if>
                      <or>
                        <resourcecount refid="build.tmp.possibleModifiedJars" when="greater" count="1" />
                        <resourcecount refid="build.tmp.possibleJars" when="greater" count="1" />
                      </or>
                      <then>
                        <echo level="warn">Skipping the modification of jar ${resMapper.placeInJar}, because there were at least two possible jars</echo>
                      </then>
                      <!-- the jar was modified already -->
                      <elseif>
                        <resourcecount refid="build.tmp.possibleModifiedJars" when="equal" count="1" />
                        <then>
                          <var name="build.tmp.modifiedJarSet" value="build.tmp.possibleModifiedJars" />
                        </then>
                      </elseif>
                      <!-- we found the jar that was not modified yet -->
                      <elseif>
                        <resourcecount refid="build.tmp.possibleJars" when="equal" count="1" />
                        <then>
                          <var name="build.tmp.modifiedJarSet" value="build.tmp.possibleJars" />
                        </then>
                      </elseif>
                      <!-- we didn't find any -->
                      <else>
                        <echo level="warn">The jar ${resMapper.placeInJar} could not be modified, because it could not be found</echo>
                      </else>
                    </if>

                    <!-- find the jar -->
                    <first id="build.tmp.modifiedJar">
                      <fileset refid="${build.tmp.modifiedJarSet}" />
                    </first>
                    
                    <!-- set the new name within the same structure -->
                    <fileReplaceName file="${toString:build.tmp.modifiedJar}" renameTo="${build.tmp.modFileName}" property="build.tmp.modFilePath" />

                    <!-- update the jar -->
                    <if>
                      <matches string="${build.tmp.destResource}" pattern="META\-INF[\\/]MANIFEST.MF" />
                      <then>
                        <jar destfile="${build.tmp.modFilePath}.tmp" manifest="${build.tmp.destBaseFolder}/${build.tmp.destResource}">
                          <zipfileset includes="**/*" src="${toString:build.tmp.modifiedJar}" />
                        </jar>
                      </then>
                      <else>
                        <jar destfile="${build.tmp.modFilePath}.tmp" update="true" duplicate="preserve" filesetmanifest="merge">
                          <fileset dir="${build.tmp.destBaseFolder}" />
                          <zipfileset includes="**/*" src="${toString:build.tmp.modifiedJar}" />
                        </jar>
                      </else>
                    </if>
                    <move file="${build.tmp.modFilePath}.tmp" tofile="${build.tmp.modFilePath}" />
                    
                    <!-- delete the original jar -->
                    <if>
                      <not><equals arg1="${build.tmp.modFilePath}" arg2="${toString:build.tmp.modifiedJar}" /></not>
                      <then>
                        <echo level="debug">Removing the unmodified version ${toString:build.tmp.modifiedJar} of the modified jar</echo>
                        
                        <fileCleanUp file="${toString:build.tmp.modifiedJar}" />
                      </then>
                    </if>
                  </then>
                </if>
              </else>
            </if>
          </then>
        </elseif>
      </if>

      <!-- execute after -->
      <if>
        <and>
          <not><equals arg1="${resMapper.removeAfter}" arg2="" /></not>
          <equals arg1="${fileInfo.exist}" arg2="true" />
        </and>
        <then>
          <echo level="info">Mapper cleans '@{rootFolder}/${resMapper.location}' afterwards using pattern '${resMapper.removeAfter}'</echo>
          
          <fileCleanUp>
            <fileset dir="@{rootFolder}/${resMapper.location}" includes="${resMapper.removeAfter}"/>
          </fileCleanUp>
        </then>
      </if>
      
      <resetLogLevel />
    </sequential>
  </macrodef>
    
  <macrodef name="resourceMapper">
    <attribute name="resourceFolder" />
    <attribute name="resourceFileName" />
    <attribute name="resource" />
    <attribute name="resourceType" />
    
    <sequential>
      <!-- do nothing per default -->
    </sequential>
  </macrodef>
  
  <macrodef name="buildZip">  
    <sequential>
    
      <!-- make sure we have an assembly -->
      <if>
        <or>
          <not><isset property="build.appDir"/></not>
            <equals arg1="${build.appDir}" arg2="" />
        </or>
        <then>
          <fail>No latest assembly found, the application cannot be packed</fail>
        </then>
      </if>
      
      <mavenSetPom />
      
      <!-- pack it -->
      <buildGetArtifactName property="build.appFile" type="app" />
      <zip basedir="${build.appDir}" destfile="${build.appFile}" />
    </sequential>
  </macrodef>
  
  <macrodef name="buildInstallLatestAssembly">
    <attribute name="classifier" default="" />
    <attribute name="type" default="${build.assembly.maven.type}" />
    
    <sequential>
      <if>
        <or>
          <not><isset property="build.appFile"/></not>
          <equals arg1="${build.appFile}" arg2="" />
        </or>
        <then>
          <fail>No latest assembly found, nothing is deployed</fail>
        </then>
        <else>
          <mavenSetPom pomid="build.tmp.pomAssembly" />
          
          <!-- create the pom-file -->
          <mavenCreateIndependentPom pomid="build.tmp.pomApp" groupid="${build.applications.groupId}" name="${build.tmp.pomAssembly.name}" packaging="@{type}"
                                     artifactid="${build.tmp.pomAssembly.artifactId}" version="${build.tmp.pomAssembly.version}" />
                                     
          <!-- install as attachment or just install -->
          <if>
            <equals arg1="@{classifier}" arg2="" />
            <then>
              <mavenInstall file="${build.appFile}" pomid="build.tmp.pomApp" />              
            </then>
            <else>
              <mavenInstallAttachment file="${build.appFile}" classifier="@{classifier}" pomid="build.tmp.pomApp" type="@{type}" />
            </else>
          </if>
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <!--
    buildDeployLatestAssembly - deployes the latest assembly to the reponsible repository
    -->
  <macrodef name="buildDeployLatestAssembly">
    <attribute name="classifier" default="" />
    <attribute name="type" default="${build.assembly.maven.type}" />
    
    <sequential>
      <if>
        <or>
          <not><isset property="build.appFile"/></not>
          <equals arg1="${build.appFile}" arg2="" />
        </or>
        <then>
          <fail>No latest assembly found, nothing is deployed</fail>
        </then>
        <else>
          <mavenSetPom pomid="build.tmp.pomAssembly" />
          
          <!-- create the pom-file -->
          <mavenCreateIndependentPom pomid="build.tmp.pomApp" groupid="${build.applications.groupId}" name="${build.tmp.pomAssembly.name}" packaging="@{type}"
                                     artifactid="${build.tmp.pomAssembly.artifactId}" version="${build.tmp.pomAssembly.version}" />
                                     
          <!-- deploy as attachment or just deploy -->
          <if>
            <equals arg1="@{classifier}" arg2="" />
            <then>
              <mavenDeploy file="${build.appFile}" pomid="build.tmp.pomApp" />              
            </then>
            <else>
              <mavenDeployAttachment file="${build.appFile}" classifier="@{classifier}" pomid="build.tmp.pomApp" type="@{type}" />
            </else>
          </if>
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="buildCheckReleaseConditions">
   
    <sequential>    
      <if>
        <!-- SVN must be available -->
        <or>
          <not><isset property="svn.repository.offline"/></not>
          <equals arg1="${svn.repository.offline}" arg2="true" />
        </or>
        <then>
          <fail>Cannot release anything, because the SVN Repository is not available</fail>
        </then>
        
        <!-- MAVEN must be available -->
        <elseif>
          <or>
            <not><isset property="maven.repository.source.offline"/></not>
            <equals arg1="${maven.repository.source.offline}" arg2="true" />
          </or>
          <then>
            <fail>Cannot release anything, because the source Maven Repository is not available</fail>
          </then>
        </elseif>
        <elseif>
          <or>
            <not><isset property="maven.repository.target.offline"/></not>
            <equals arg1="${maven.repository.target.offline}" arg2="true" />
          </or>
          <then>
            <fail>Cannot release anything, because the target Maven Repository is not available</fail>
          </then>
        </elseif>
        
        <else>
          <!-- check for updates -->
          <svnUpdate />

          <!-- make sure there are no files unversioned or not yet updated -->
          <svnCheckUnversioned />

          <!-- check that all dependency are releases -->
          <mavenCheckVersionName />
          <mavenCheckSnapshotDependencies scopes="${build.release.scopes}" />

          <!-- now commit -->
          <svnCommit message="Commit prior to release of version '${maven.pom.version}'" />

          <!-- check if everything is done now -->
          <svnCheckFullCommit />
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <!-- the targets to build, install, deploy, assemble -->
  <target name="build">
    <buildBuild />
    <buildPack />
  </target>
  
  <target name="javadoc">
    <buildJavaDoc />
    <buildPackJavaDoc />
  </target>
  
  <target name="sources">
    <buildPackSource />
  </target>

  <target name="assemble" depends="build">
    <buildAssembly />
    <buildZip />
  </target>
  
  <target name="installAssembly" depends="install, assemble">
    <buildInstallLatestAssembly />
  </target>

  <target name="deployAssembly" depends="deploy, assemble">
    <buildDeployLatestAssembly />
  </target>

  <target name="install" depends="build, javadoc, sources">
    <buildInstallLatestBuild />
  </target>
  
  <target name="deploy" depends="build, javadoc, sources">
    <buildDeployLatestBuild />
  </target>
  
  <target name="fullDeploy" depends="deploy, testDeploy" />
    
  <target name="removePreBuilds">
    <buildRemovePreBuilds />
  </target>
  
  <target name="release" depends="removePreBuilds, testRemovePreBuilds">
  
    <!-- check the availability of SVN and Maven -->
    <buildCheckReleaseConditions />
    
    <!-- create the build -->
    <if>
      <available file="${basedir}/pom.xml" />
      <then>
        <buildRemovePreBuilds />
        <buildBuild />
        <buildPack />
        <buildJavaDoc />
        <buildPackJavaDoc />
        <buildPackSource />
        
        <!-- test the version -->
        <testRemovePreBuilds />
        <testTest />
        <testPackSource />
      </then>
    </if>
    
    <!-- lets tag everything -->
    <svnTag message="Release of ${maven.pom.version}" />
    
    <!-- lets deploy the binaries, source and javadoc -->
    <if>
      <available file="${basedir}/pom.xml" />
      <then>
        <buildDeployLatestBuild />
        <testDeployLatestBuild />
      </then>
    </if>
    
    <!-- create the assembly -->
    <if>
      <and>
        <equals arg1="${build.assembly.create}" arg2="true" />
      </and>
      <then>
        <buildAssembly />
        <buildZip />
        <buildDeployLatestAssembly />
      </then>
    </if>
    
    <!-- deploy the parents -->
    <mavenDeployParents />

    <echo level="warn">Please modify the needed files now! Especially modify the version number in the pom.xml and/or your parent-poms, so that a new generation of this artifact can be developed</echo>
  </target>
  
  <target name="fullBuild" depends="removePreBuilds, build" />
</project>