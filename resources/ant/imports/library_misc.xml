<!--
  Library which adds some nice to have macros and targets 
  
  Created on: 01.03.2012
  Created by: Philipp Meisen <philipp@meisen.net>
  History:
    01.03.2012
      - Creation of library
    12.02.2013
      - added the 'appendList' task
    14.06.2013
      - added the 'unsetProperties' task
      - modified the 'modifyProperties' to support the add prefixhandler
  -->
<project name="library_misc">
  <property name="misc.library.version" value="1.4.0" description="The current version of the library" />
  <dirname property="library_misc.basedir" file="${ant.file.library_misc}"/>
  
  <property name="misc.batch.name" value="antRunAsync" description="The general name of the script/batch to be executed" />
  <property name="misc.batch.location" value="${main.root}/helper/antRunAsync" description="The location of the script/batch to be executed" />
  <property name="misc.batch.genericPath" value="${misc.batch.location}/${misc.batch.name}" description="The execution to be used generally to work under Unix and Windows" />
  
  <property name="misc.library.resfile.batch.unix" location="${misc.batch.location}/${misc.batch.name}" description="Script to be executed (Unix)" />
  <property name="misc.library.resfile.batch.windows" location="${misc.batch.location}/${misc.batch.name}.bat" description="Batch file to be executed (Windows)" />
  <property name="misc.library.resfile.js.window" location="${misc.batch.location}/${misc.batch.name}.js" description="Additional JavaScript needed (Windows)" />
  <property name="misc.library.resfile.js.sleep" location="${misc.batch.location}/sleep.js" description="Additional JavaScript for sleep - often needed while waiting for ant finish (Windows)" />
  
  <!--
    generateUUID - generates a UUID and sets the passed property to the specified value
    -->
  <scriptdef name="generateUUID" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");

    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(java.util.UUID.randomUUID().toString());
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="replaceAndSetProperty" language="javascript">
    <attribute name="property" />
    <attribute name="value" />
    <attribute name="replace" />
    <attribute name="replacement" />
    
    <![CDATA[
      var property = attributes.get("property");
      var value = attributes.get("value");
      var replace = attributes.get("replace");
      var replacement = attributes.get("replacement");
      
      project.setProperty(property, value.replace(replace, replacement));
    ]]>
  </scriptdef>
  
  <scriptdef name="incProperty" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");
    var propValue = project.getProperty(property);
    
    var value = Number(propValue == null ? 0 : propValue);
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(value + 1);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="decProperty" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");
    var propValue = project.getProperty(property);
    
    var value = Number(propValue == null ? 0 : propValue);
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(value - 1);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    setLogLevel - specifies the logging level to be used by ant
    -->
  <scriptdef name="setLogLevel" language="javascript">
    <attribute name="logLevel"/>
    <![CDATA[
    var loglevel = attributes.get("loglevel");
    
    // create a stack of logLevel set
    var logLevelStack = project.getReference("misc.setLogLevel.stack");
    if (logLevelStack == null) {
      logLevelStack = new java.util.Stack();
      project.addReference("misc.setLogLevel.stack", logLevelStack);
    }
    
    // the default is 2 ==> warn
    var loglevelValue = 2;
    if (loglevel == "error") {
      loglevelValue = 0;
    } else if (loglevel == "warn") {
      loglevelValue = 1;
    } else if (loglevel == "info") {
      loglevelValue = 2;
    } else if (loglevel == "verbose") {
      loglevelValue = 3;
    } else if (loglevel == "debug") {
      loglevelValue = 4;
    }
    
    // get the logger
    var listener = project.getBuildListeners();
    var firstListener = listener.get(0);

    // keep the current logLevel
    var fields = firstListener.getClass().getDeclaredFields();
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      var fieldName = field.getName();
      
      // get the current logLevel
      if (fieldName.equals("msgOutputLevel")) {
        field.setAccessible(true);
        logLevelStack.push(field.get(firstListener));        
        field.setAccessible(false);
        break;
      }
    }
    
    // set the logLevel
    firstListener.setMessageOutputLevel(loglevelValue);
    ]]>
  </scriptdef>
  
  <scriptdef name="resetLogLevel" language="javascript">
    <![CDATA[
    var loglevelValue = 2;
    
    // create a stack of logLevel set
    var logLevelStack = project.getReference("misc.setLogLevel.stack");
    if (logLevelStack != null) {
      loglevelValue = logLevelStack.pop();
    }
    
    // set the logLevel
    var listener = project.getBuildListeners();
    var firstListener = listener.get(0);
    firstListener.setMessageOutputLevel(loglevelValue);
    ]]>
  </scriptdef>
  
  <scriptdef name="executeSimpleMacroByName" language="javascript">
    <attribute name="task" />
    
    <![CDATA[
    var tn = attributes.get("task");
    var t = project.createTask(tn);

    var execute = true;
    
    if (t instanceof org.apache.tools.ant.taskdefs.MacroInstance) {    
      var tAttributes = t.getMacroDef().getAttributes();
           
      // check if all attributes are optional
      for (var i = 0; i < tAttributes.size(); ++i) {
        var tAttribute = tAttributes.get(i);
        if (tAttribute.getDefault() == null) {
        
          // it's not a simple task
          execute = false;
        }
      }
    } else {
      execute = false;
    }
    
    if (execute) {
      t.execute();
    }
    ]]>
  </scriptdef>
  
  <scriptdef name="checkTarget" language="javascript" description="">
    <attribute name="property" />
    <attribute name="target" />
    <![CDATA[
    // the property to be set and the target to be checked
    var userProperty = attributes.get("property");
    var target = attributes.get("target");
    
    // the property to be read
    var property = "ant.project.cmd-invoked-targets";
    
    // get the property
    var foundEntry = false;
    var invokedTargets = project.getProperty(property);
    if (invokedTargets == null || invokedTargets.equals("")) {
    
      // create an error logger
      var errorMsg = project.createTask("echo");
      var error = Packages.org.apache.tools.ant.taskdefs.Echo.EchoLevel(); 
      error.setValue("error");
      errorMsg.setLevel(error);
      errorMsg.setMessage("The " + property + " is not available, please check the used starting routine and the used main-class.");
      errorMsg.perform();
    } else {
    
      // check the list of targets
      var listEntries = invokedTargets.split("\\s*,\\s*");
      var sizeOfList = listEntries.length;
      for (var i = 0; i < sizeOfList && !foundEntry; i++) {
        var entry = listEntries[i];
        foundEntry = foundEntry || entry.equals(target);
      }
    }
    
    // set the userProperty
    var setProperty = project.createTask("var");
    setProperty.setName(userProperty);
    setProperty.setValue("" + foundEntry);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    transformPackageToPath - transforms the passed (comma-separated) packages to a path which selects all
                             files (incl. files in sub-directories) from the package
    -->
  <scriptdef name="transformPackagesToPath" language="javascript">
    <attribute name="property" />
    <attribute name="packages" />
    <attribute name="suffix" />
    <attribute name="packageSeparatore" />
    <attribute name="separatore" />
    
    <![CDATA[
    var property = attributes.get("property");
    var packs = attributes.get("packages");
    var suffix = attributes.get("suffix");
    var packageSeparatore = attributes.get("packageseparatore");
    var separatore = attributes.get("separatore");
        
    if (packs == null || packs.trim() == "") {
      packs = "";
    } else {
      var split = packs.split(",");
      
      var pack = "";
      packs = "";
      for (var i = 0; i < split.length; i++) {
        pack = split[i].trim();
        pack = pack.replace('.', packageSeparatore);
        pack += suffix;
        
        packs += (packs == "" ? "" : separatore) + pack;
      }
    }
    
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(packs);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    This method is used creates list based on an already created list, by appending a value to it only and 
    only if the value isn't in the list yet. The newly created list will never end on the passed separator.
    
    @param property
      the property to set with the created list
    @param list
      the list to append the value to
    @param value
      the value to add to the list if it's not in the list yet
    @param <span style="text-decoration:line-through">separatore</span>
      this attribute is <b>deprecated</b> and should not be used, use <i>separator</i> instead
    @param separator
      the separator to be used to separate the values from each other
      
    @fails 
      <ul>
        <li>if the specified <i>resourceCollectionId</i> points to a not existing resource collection</li>
      </ul>
            
    @author Philipp Meisen
    @since 1.1.0
  -->
  <scriptdef name="createList" language="javascript">
    <attribute name="property" />
    <attribute name="list" />
    <attribute name="value" />
    <attribute name="separatore" />
    <attribute name="separator" />
    
    <![CDATA[
    var property = attributes.get("property");
    var list = attributes.get("list");
    var separator = attributes.containsKey("separator") ? attributes.get("separator") : attributes.get("separatore");
    var value = attributes.get("value");
    value = value.trim();

    var listEntries = list.split("\\s*" + separator + "\\s*");
    
    var finalList = "";
    var sizeOfList = listEntries.length;
    var foundEntry = false;
    for (var i = 0; i < sizeOfList; i++) {
      var entry = listEntries[i];
      var lastEntry = sizeOfList - 1 == i;
      foundEntry = foundEntry || entry.equals(value);
      
      finalList += entry + (lastEntry ? "" : separator);
    }
    
    if (!foundEntry) {
      finalList += (sizeOfList > 0 && !finalList.equals("") ? separator : "") + value;
    }
    
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(finalList);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    appendList - Appends a list (i.e. list1) to another list (i.e. list2), whereby duplicates will be removed
    -->
  <scriptdef name="appendList" language="javascript">
    <attribute name="property" />
    <attribute name="list1" />
    <attribute name="list2" />
    <attribute name="separator" />
    <attribute name="trimItems" />
    
    <![CDATA[
    var createSet = function(csvlist, separator, trim) {
      var set;
      
      if (csvlist == null || "".equals(csvlist)) {
        set = new java.util.LinkedHashSet();
      } else {
        var listEntries = csvlist.split("\\s*\\Q" + separator + "\\E\\s*");
        var list = java.util.Arrays.asList(listEntries);
        var set = new java.util.LinkedHashSet(list);
      }
      
      if (trim) {
        var trimmedSet = new java.util.LinkedHashSet();
        
        var iterator = set.iterator();
        while(iterator.hasNext()) {
          var value = iterator.next();
          trimmedSet.add(value.trim());
        }
        set = trimmedSet;
      }
      
      return set;
    };
      
    var property = attributes.get("property");
    var csvList1 = attributes.get("list1");
    var csvList2 = attributes.get("list2");
    var separator = attributes.get("separator");
    var trimItems = attributes.containsKey("trimitems") ? attributes.get("trimitems") : "false";
    trimItems = trimItems.equals("true") || trimItems.equals("yes") || trimItems.equals("y")
    
    // create the sets and merge those
    var set1 = createSet(csvList1, separator, trimItems);
    var set2 = createSet(csvList2, separator, trimItems);
    set1.addAll(set2);
            
    // build the new list
    var sb = new java.lang.StringBuilder();
    var loopSeparator = "";
    var iterator = set1.iterator();
    while(iterator.hasNext()) {
      sb.append(loopSeparator);
      sb.append(iterator.next());            
      loopSeparator = separator;
    }
    
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(sb.toString());
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="replacePropertiesInProperties" language="javascript">
    <attribute name="propertySetId" />
    <!-- optional attributes -->
    <attribute name="loopUntilAllReplaced" />    <!-- default: true  -->
    <attribute name="sortAlphanumeric" />        <!-- default: false -->
    <attribute name="propertyMarker" />          <!-- default: $     -->
    
    <![CDATA[
    var propertySetId = attributes.get("propertysetid");
    var loopUntilAllReplaced = attributes.containsKey("loopuntilallreplaced") ? attributes.get("loopuntilallreplaced").equals("true") : true;
    var sortAlphanumeric = attributes.containsKey("sortalphanumeric") ? attributes.get("sortalphanumeric").equals("true") : false;
    var propertyMarker = attributes.containsKey("propertymarker") ? attributes.get("propertymarker") : "$";
    var properties = project.hasReference(propertySetId) ? project.getReference(propertySetId) : null;

    // helper method to load js files
    // thanks to http://stackoverflow.com/questions/650377/javascript-rhino-use-library-or-include-other-scripts
    var l = function(property) {
      var jsFile = project.getProperty(property);
      var fileReader = new java.io.FileReader(jsFile);
      var fullRead = org.apache.tools.ant.util.FileUtils.readFully(fileReader);
      
      return "" + new java.lang.String(fullRead);
    }
    
    // load the libraries
    eval(l("main.library.resfile.js.general"));
    
    // get the properties
    if (properties != null && properties.size() > 0) {
      var changes = true;

      var propertyIter = properties.iterator();
      var set = sortAlphanumeric ? new java.util.TreeSet() : new java.util.LinkedHashSet();
      while (propertyIter.hasNext()) {
        set.add(propertyIter.next());
      }

      while (changes) {
        var propertyIter = set.iterator();
        changes = false;

        while (propertyIter.hasNext()) {       
          var property = propertyIter.next();
          var propertyKey = property.getName();
          var propertyValue = property.getValue();

          var propertyNewValue = replaceProperties(propertyValue, project.getProperties(), propertyMarker, loopUntilAllReplaced);            
          var propertySet = !propertyValue.equals(propertyNewValue);

          // set the new value if it changed
          if (propertySet) {
            var quotedNewValue = quoteAntProperties(propertyNewValue);
          
            var setProperty = project.createTask("var");
            setProperty.setName(propertyKey);
            setProperty.setValue(quotedNewValue);
            setProperty.execute();
            changes = loopUntilAllReplaced;
          } 
        }
      }
    }
    ]]>
  </scriptdef>
  
  <!--
    This method is used to transform a <i>resourceCollection</i> into a list (separated by the specified <i>separator</i>).
    
    @param property
      the property to set with the created list
    @param resourceCollectionId
      the id of the <i>resourceCollection</i> to be transformed to a list
    @param <span style="text-decoration:line-through">separatore</span>
      this attribute is <b>deprecated</b> and should not be used, use <i>separator</i> instead
    @param separator
      the separator to be used to separate the values from each other
    @param pattern[{value}]
      the pattern used to modify the look of the outcome
      
    @fails 
      <ul>
        <li>if the specified <i>resourceCollectionId</i> points to a not existing resource collection</li>
      </ul>
            
    @author Philipp Meisen
    @since 1.1.0
  -->
  <scriptdef name="createResourceList" language="javascript">
    <attribute name="property" />
    <attribute name="resourceCollectionId" />
    <attribute name="separatore" />
    <attribute name="separator" />
    
    <element name="mapper" type="mapper" />
    
    <![CDATA[
    var property = attributes.get("property");
    var resourceCollectionId = attributes.get("resourcecollectionid");
    var separator = attributes.containsKey("separator") ? attributes.get("separator") : attributes.get("separatore");
    
    // get the resource collection
    var refs = project.hasReference(resourceCollectionId) ? project.getReference(resourceCollectionId) : null;
    
    // check if there is a mapper
    var mappers = elements.get("mapper");
    var mapper;
    if (mappers == null) {
      mapper = null;
    } else if (mappers.size() > 1) {
      self.fail("The createResourceList supports a maximum of one mapper, please use chainedMapper to combine several mappers.");
    } else {
      mapper = mappers.get(0);
      mapper = mapper.getImplementation();
    }
    
    // check the resource collection
    var finalList = "";
    if (refs != null && refs.size() > 0) {
      var entries = refs.iterator();
      
      finalList = separator;
      while (entries.hasNext()) {
        var value;
        var entry = entries.next();
        if (entry instanceof org.apache.tools.ant.types.resources.PropertyResource ||
            entry instanceof org.apache.tools.ant.types.resources.StringResource) {
          value = entry.getValue();
        } else if (entry instanceof org.apache.tools.ant.types.resources.URLResource) {
          value = entry.getURL() == null ? "" : entry.getURL().toString();
        } else if (entry instanceof org.apache.tools.ant.types.resources.FileResource) {
          try {
            value = entry.getFile() == null ? "" : entry.getFile().getCanonicalPath();
          } catch (e) {
            value = entry.getFile() == null ? "" : entry.getFile().getAbsolutePath();
          }
        } else {
          value = entry == null ? "" : entry.toString();
        }
        
        // use the mapper if there is one
        if (mapper != null) {
          value = mapper.mapFileName(value);
          value = value == null ? null : value[0];
        }
        
        finalList = finalList + value + separator;
      }
      
      var length = separator.length();
      var listLength = finalList.length;      
      finalList = finalList.substring(length, listLength - length);
    }
       
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(finalList);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    This method is used to transform a <i>propertySet</i> into a list (separated by the specified <i>separator</i>).
    
    @param property
      the property to set with the created list
    @param resourceCollectionId
      the id of the <i>propertySet</i> to be transformed to a list
    @param separator
      the separator to be used to separate the values from each other
    @param pattern[{propertykey}={propertyvalue}]
      the pattern used to identify how a property should be represented within the list

    @fails 
      <ul>
        <li>if the specified <i>resourceCollectionId</i> points to a not existing resource collection</li>
      </ul>
            
    @author Philipp Meisen
    @since 1.1.0
  -->
  <scriptdef name="createPropertyList" language="javascript">
    <attribute name="property" />
    <attribute name="propertySetId" />
    <attribute name="separator" />
    
    <attribute name="sortAlphanumeric" />
    <attribute name="pattern" />
    
    <![CDATA[
    var setProperty = project.createTask("var");
    
    var property = attributes.get("property");
    var propertySetId = attributes.get("propertysetid");
    var separator = attributes.get("separator");
   
    var sortAlphanumeric = attributes.containsKey("sortalphanumeric") ? attributes.get("sortalphanumeric").equals("true") : false;
    var pattern = attributes.containsKey("pattern") ? attributes.get("pattern") : "{propertykey}={propertyvalue}";
   
    // get the resource collection
    var refs = project.hasReference(propertySetId) ? project.getReference(propertySetId) : null;
    
    var sb = new java.lang.StringBuilder();
    if (refs != null) {
      var props = refs.getProperties();
      if (props != null && props.size() > 0) {
      
        // sort if asked for otherwise keep insertion order
        var set = sortAlphanumeric ? new java.util.TreeMap() : new java.util.LinkedHashMap();
        set.putAll(props);

        // loop through the properties
        var loopSeparator = "";
        var iterator = set.keySet().iterator();
        while(iterator.hasNext()) {
          var key = iterator.next();
          var val = set.get(key);
          var res = pattern.replace("{propertykey}", key).replace("{propertyvalue}", val);
          
          sb.append(loopSeparator);
          sb.append(res);
          loopSeparator = separator;
        }
      }
    }
    
    // set the new list
    setProperty.setName(property);
    setProperty.setValue(sb.toString());
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="popFromList" language="javascript">
    <attribute name="property" />
    <attribute name="list" />           <!-- if listProperty is set the property will be read if this one isn't set -->
    <attribute name="order" />          <!-- default="last" -->
    <attribute name="delimiter" />      <!-- default=","  -->
    <attribute name="modifyList" />     <!-- default="true"  -->
    <attribute name="listProperty" />   <!-- default=""  -->
    
    <![CDATA[
    var echo = project.createTask("echo");
    var setProperty = project.createTask("var");
    
    var property = attributes.get("property");
    var list = attributes.containsKey("list") ? attributes.get("list") : null;
    var takeFromLast = attributes.containsKey("order") ? attributes.get("order").equals("last") : true;
    var delimiter = attributes.containsKey("delimiter") ? attributes.get("delimiter") : ",";
    var modifyList = attributes.containsKey("modifylist") ? attributes.get("modifylist").equals("true") : true;
    var listProperty = attributes.containsKey("listproperty") ? attributes.get("listproperty") : "";
    
    // get the list
    if (list == null) {
      list = project.getProperty(listProperty);
    } 
    if (list == null || "".equals(list)) {
      arrayList = new java.util.ArrayList();
    } else {
      var listEntries = list.split("\\s*\\Q" + delimiter + "\\E\\s*");
      arrayList = new java.util.ArrayList(java.util.Arrays.asList(listEntries));
    }
    
    // get the first or last value of the list
    var pos = takeFromLast ? arrayList.size() - 1 : 0;
    var val = pos > -1 && pos < arrayList.size() ? arrayList.get(pos) : null;
    
    // set the property of the taken value
    setProperty.setName(property);
    setProperty.setValue(val == null ? "" : val);
    setProperty.execute();
    
    // modify the list if asked for
    if (modifyList && val != null && listProperty != null && !"".equals(listProperty)) {
      arrayList.remove(pos);
      
      // build the new list
      var sb = new java.lang.StringBuilder();
      var loopDelimiter = "";
      var iterator = arrayList.iterator();
      while(iterator.hasNext()) {
        sb.append(loopDelimiter);
        sb.append(iterator.next());            
        loopDelimiter = delimiter;
      }
      
      // set the new list
      setProperty.setName(listProperty);
      setProperty.setValue(sb.toString());
      setProperty.execute();
    }
    ]]>
  </scriptdef>
  
  <macrodef name="importLibrariesFromList">
    <attribute name="list" />
    <attribute name="default" default="true" />
    <attribute name="force" default="false" />
  
    <sequential>

      <for list="@{list}" param="misc.tmp.library">
        <sequential>
          <!-- reset the properties -->
          <var name="misc.tmp.relfile" value="" unset="true" />
          <var name="misc.tmp.import" value="" unset="true" />
          
          <!-- get the values of the defined properties -->
          <propertycopy name="misc.tmp.relfile" from="main.library.file.@{misc.tmp.library}" />
          <propertycopy name="misc.tmp.import" from="main.import.library.@{misc.tmp.library}" silent="true" />
          
          <!-- get the file and import it -->
          <if>
            <or>
              <equals arg1="@{force}" arg2="true" />
              <and>
                <isset property="misc.tmp.import" />
                <not><equals arg1="${misc.tmp.import}" arg2="false" /></not>
              </and>
              <and>
                <equals arg1="@{default}" arg2="true" />
                <not><isset property="misc.tmp.import" /></not>
              </and>
            </or>
            <then>
              <echo level="debug">Importing library: ${misc.tmp.relfile}</echo>
              <var name="misc.tmp.file" value="${library_main.basedir}/${misc.tmp.relfile}" />
              <import file="${misc.tmp.file}" as="@{misc.tmp.library}" />
            </then>
          </if>
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <macrodef name="allLibrariesFiles">
    <attribute name="filesetid" />
  
    <sequential>
     
      <fileset id="@{filesetid}" dir="${main.root}">
        <exclude name="**/*" />
      </fileset>
      
      <mainGetLibraries property="misc.tmp.libraries" />
      <for list="${misc.tmp.libraries}" param="misc.tmp.library">
        <sequential>
          <propertycopy name="misc.tmp.import" from="main.import.library.@{misc.tmp.library}" silent="true" />
            
          <if>
            <not><equals arg1="@{misc.tmp.library}" arg2="" /></not>
            <then>
              <libraryFiles library="@{misc.tmp.library}" filesetid="misc.tmp.libraryFiles" />

              <!-- create the unions -->
              <fileCombineFilesets filesetId="@{filesetid}">
                <fileset refid="misc.tmp.libraryFiles" />
                <fileset refid="@{filesetid}" />
              </fileCombineFilesets>
            </then>
          </if>
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <macrodef name="libraryFiles">
    <attribute name="library" />
    <attribute name="filesetid" />
  
    <sequential>
      <var name="misc.tmp.library.files" value="" unset="true" />
    
      <propertyset id="misc.tmp.library.files">
        <propertyref regex="^@{library}\.library\.resfile\..+$" />
        <propertyref regex="^ant\.file\.library_@{library}$" />
      </propertyset>
 
      <!-- convert it to a path -->
      <pathconvert refid="misc.tmp.library.files" pathsep="," property="misc.tmp.library.files">
        <regexpmapper from="^\Q${main.root}\E[\\/](.+)$" to="\1"/>
      </pathconvert>
      
      <!-- get the fileset -->
      <if>
        <and>
          <isset property="misc.tmp.library.files" />
          <not><equals arg1="${misc.tmp.library.files}" arg2="" /></not>
        </and>
        <then>
          <fileset id="@{filesetid}" dir="${main.root}" includes="${misc.tmp.library.files}" />
        </then>
        <else>
          <echo level="warn">Warning: The @{library}-library was not included and therefore won't be included in the wrap-up</echo>
          <fileset id="@{filesetid}" dir="${main.root}">
            <exclude name="**/*" />
          </fileset>
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="asyncExec">
    <attribute name="exec" />
    <attribute name="title" default="ant async exec" />
    <attribute name="workingDir" default ="." />
    <attribute name="arg1" default ="" />
    <attribute name="arg2" default ="" />
    <attribute name="arg3" default ="" />
    <attribute name="arg4" default ="" />
    <attribute name="arg5" default ="" />
    
    <sequential>
      <exec executable="${misc.batch.genericPath}" dir="@{workingDir}" vmlauncher="false" failonerror="true">
        <env key="ANTRUN_TITLE" value="@{title}" />
        <!-- actual executable and arguments to run -->
        <arg line="@{exec}" />
        <arg line="@{arg1}" />
        <arg line="@{arg2}" />
        <arg line="@{arg3}" />
        <arg line="@{arg4}" />
        <arg line="@{arg5}" />
      </exec>
    </sequential>
  </macrodef>
  
  <macrodef name="unsetProperties">
    <attribute name="propertySetId" default="misc.tmp.propertySet" />
    
    <sequential>
      <var name="misc.tmp.propertySetId" value="@{propertySetId}" />
      
      <script language="javascript"><![CDATA[
        var propertySetId = project.getProperty("misc.tmp.propertySetId");
        var properties = project.hasReference(propertySetId) ? project.getReference(propertySetId) : null;
        
        if (properties != null && properties.size() > 0) {
          var iterator = properties.iterator();
          
          // create the task to unset the properties
          var unsetProperty = project.createTask("var");
          unsetProperty.setValue(null);
          unsetProperty.setUnset(true);

          while (iterator.hasNext()) {             
            var property = iterator.next();
            
            // unset it
            unsetProperty.setName(property.getName());
            unsetProperty.execute();
          }
        }
      ]]></script>
    </sequential>
  </macrodef>
  
  <macrodef name="modifyProperties">
    <attribute name="prefix" />
    <attribute name="propertySetId" default="misc.tmp.propertySet" />
    <attribute name="resultPropertySetId" default="misc.tmp.resultPropertySet" />
    <attribute name="setPropertiesWithoutPrefix" default="true" />
    <attribute name="unsetProperties" default="false" />
    <attribute name="skipPattern" default="" />
    <attribute name="prefixhandling" default="remove" />
    
    <sequential>
    
      <!-- get all the passed values -->
      <var name="misc.tmp.prefix" value="@{prefix}" />
      <var name="misc.tmp.propertySetId" value="@{propertySetId}" />
      <var name="misc.tmp.resultPropertySetId" value="@{resultPropertySetId}" />
      <var name="misc.tmp.skipPattern" value="@{skipPattern}" />
      <var name="misc.tmp.prefixhandling" value="@{prefixhandling}" />
      <varNormalizeBoolean property="misc.tmp.setPropertiesWithoutPrefix" value="@{setPropertiesWithoutPrefix}" />
      <varNormalizeBoolean property="misc.tmp.unsetProperties" value="@{unsetProperties}" />
      
      <!-- define the regular expression to select the properties which have to be modified -->
      <if>
        <equals arg1="${misc.tmp.prefixhandling}" arg2="remove" />
        <then>
          <var name="misc.tmp.propertyRegEx" value="^\Q@{prefix}\E\.(.+)$" />
          
          <!-- create the set -->
          <propertyset id="@{propertySetId}">
            <propertyref regex="${misc.tmp.propertyRegEx}" />
          </propertyset>
        </then>
        <else>
          <var name="misc.tmp.propertyRegEx" value="^(.+)$" />
          
          <!-- the set should already be available -->          
        </else>
      </if>
      
      <!-- set the properties without a prefix -->
      <if>
        <or><equals arg1="${misc.tmp.setPropertiesWithoutPrefix}" arg2="true" /><equals arg1="${misc.tmp.unsetProperties}" arg2="true" /></or>
        <then>

          <script language="javascript"><![CDATA[
            var setProperty = project.createTask("var");
          
            var prefix = project.getProperty("misc.tmp.prefix");
            var propertyRegEx = project.getProperty("misc.tmp.propertyRegEx");
            var propertySetId = project.getProperty("misc.tmp.propertySetId");
            var resultPropertySetId = project.getProperty("misc.tmp.resultPropertySetId");
            var setPropertiesWithoutPrefix = project.getProperty("misc.tmp.setPropertiesWithoutPrefix");
            var unsetProperties = project.getProperty("misc.tmp.unsetProperties");
            var skipPattern = project.getProperty("misc.tmp.skipPattern");
            var prefixhandling = project.getProperty("misc.tmp.prefixhandling");
            
            // get the collection
            var properties = project.hasReference(propertySetId) ? project.getReference(propertySetId) : null;
            
            // create the result property set
            var resultPropertySet = new org.apache.tools.ant.types.PropertySet();
            resultPropertySet.setProject(project);
            
            // iterate over the properties
            if (properties != null && properties.size() > 0) {
              var iterator = properties.iterator();

              while (iterator.hasNext()) {              
                var property = iterator.next();
                var propertyPattern = java.util.regex.Pattern.compile(propertyRegEx);
                var propertyMatcher = propertyPattern.matcher(property.getName());
                
                // trigger the regex we will find something and get the value
                propertyMatcher.find();
                var propertySuffix = propertyMatcher.group(1);
                
                // check if the property should be skipped, i.e. is excluded from modification
                var isSkipped = !"".equals(skipPattern) && propertySuffix.matches(".*" + skipPattern + ".*");
                
                // set the property if asked for
                var addPropertyName = null;
                if (isSkipped) {
                  // do nothing
                } else if (prefixhandling.toLowerCase().equals("add")) {
                  addPropertyName = prefix + "." + propertySuffix;
                } else if (prefixhandling.toLowerCase().equals("remove") && "true".equals(setPropertiesWithoutPrefix)) {
                  addPropertyName = propertySuffix;
                }
                
                // add the property to the result
                if (addPropertyName != null) {
                  setProperty.setName(addPropertyName);
                  setProperty.setValue(property.getValue());
                  setProperty.execute();
                
                  var propertyRef = new org.apache.tools.ant.types.PropertySet.PropertyRef();
                  propertyRef.setRegex("^\\Q" + addPropertyName + "\\E$");
                  resultPropertySet.addPropertyref(propertyRef);
                }
                
                // unset the property if asked for
                if ("true".equals(unsetProperties)) {
                  var unsetProperty = project.createTask("var");
                  unsetProperty.setName(property.getName());
                  unsetProperty.setValue(null);
                  unsetProperty.setUnset(true);
                  unsetProperty.execute();
                }
              }
            }
            
            project.addReference(resultPropertySetId, resultPropertySet);
          ]]></script>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="varKeep">
    <attribute name="name" />
    <attribute name="value" />
    <attribute name="property" />
    
    <sequential>
      <var name="@{property}" value="" unset="true" />
      <if>
        <isset property="@{name}" />
        <then>
          <propertycopy name="@{property}" from="@{name}" />
        </then>
      </if>
      <var name="@{name}" value="@{value}" />
    </sequential>
  </macrodef>
  
  <macrodef name="varNvl">
    <attribute name="property" />
    <attribute name="value" />
    
    <sequential>
      <if>
        <not><isset property="@{property}" /></not>
        <then>
          <var name="@{property}" value="@{value}" />
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="varEmpty">
    <attribute name="property" />
    <attribute name="value" />
    <attribute name="default" />
    
    <sequential>
      <if>
        <equals arg1="@{value}" arg2="" />
        <then>
          <var name="@{property}" value="@{default}" />
        </then>
        <else>
          <var name="@{property}" value="@{value}" />
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="varLocation">
    <attribute name="property" />
    <attribute name="value" />
    
    <sequential>
      <var name="@{property}" unset="true" />
      <property name="@{property}" location="@{value}" />
    </sequential>
  </macrodef>
  
  <macrodef name="varNormalizeBoolean">
    <attribute name="property" />
    <attribute name="value" default="" />
    
    <sequential>
      <var name="misc.tmp.value" unset="true" />
    
      <!-- get the property to be set, by default it is the one read -->
      <if>
        <equals arg1="@{value}" arg2="" />
        <then>
          <propertycopy name="misc.tmp.value" from="@{property}" />
        </then>
        <else>
          <var name="misc.tmp.value" value="@{value}" />
        </else>
      </if>
    
      <if>
        <or><equals arg1="${misc.tmp.value}" arg2="y" /><equals arg1="${misc.tmp.value}" arg2="yes" /><equals arg1="${misc.tmp.value}" arg2="true" /></or>
        <then><var name="@{property}" value="true" /></then>
        <else><var name="@{property}" value="false" /></else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="getPackageAndClass">
    <attribute name="qualifiedName" />
    <attribute name="packageProperty" default="misc.tmp.package" />
    <attribute name="classProperty" default="misc.tmp.class" />
    
    <sequential>
      <var name="misc.tmp.regex" value="^(?:([^ \-]*)\.)?([a-z_][^\. \-]*)$" />
      
      <!-- reset the propeties -->
      <var name="@{packageProperty}" unset="true" />
      <var name="@{classProperty}" unset="true" />
      
      <!-- set them again -->
      <propertyregex property="@{packageProperty}" input="@{qualifiedName}" regexp="${misc.tmp.regex}" select="\1" casesensitive="false" />
      <propertyregex property="@{classProperty}" input="@{qualifiedName}" regexp="${misc.tmp.regex}" select="\2" casesensitive="false" />
    </sequential>
  </macrodef>
</project>