<!--
  Library which adds some nice to have macros and targets 
  
  Created on: 01.03.2012
  Created by: Philipp Meisen <philipp@meisen.net>
  History:
    01.03.2012
      - Creation of library
    12.02.2013
      - added the 'appendList' task
  -->
<project name="library_misc">
  <property name="misc.library.version" value="1.2.0" description="The current version of the library" />
  <dirname property="library_misc.basedir" file="${ant.file.library_misc}"/>
  
  <property name="misc.batch.name" value="antRunAsync" description="The general name of the script/batch to be executed" />
  <property name="misc.batch.location" value="${main.root}/helper/antRunAsync" description="The location of the script/batch to be executed" />
  <property name="misc.batch.genericPath" value="${misc.batch.location}/${misc.batch.name}" description="The execution to be used generally to work under Unix and Windows" />
  
  <property name="misc.library.resfile.batch.unix" location="${misc.batch.location}/${misc.batch.name}" description="Script to be executed (Unix)" />
  <property name="misc.library.resfile.batch.windows" location="${misc.batch.location}/${misc.batch.name}.bat" description="Batch file to be executed (Windows)" />
  <property name="misc.library.resfile.js.window" location="${misc.batch.location}/${misc.batch.name}.js" description="Additional JavaScript needed (Windows)" />
  <property name="misc.library.resfile.js.sleep" location="${misc.batch.location}/sleep.js" description="Additional JavaScript for sleep - often needed while waiting for ant finish (Windows)" />
  
  <!--
    generateUUID - generates a UUID and sets the passed property to the specified value
    -->
  <scriptdef name="generateUUID" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");

    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(java.util.UUID.randomUUID().toString());
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="incProperty" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");
    var propValue = project.getProperty(property);
    
    var value = Number(propValue == null ? 0 : propValue);
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(value + 1);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="decProperty" language="javascript">
    <attribute name="property" />
    <![CDATA[
    var property = attributes.get("property");
    var propValue = project.getProperty(property);
    
    var value = Number(propValue == null ? 0 : propValue);
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(value - 1);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    setLogLevel - specifies the logging level to be used by ant
    -->
  <scriptdef name="setLogLevel" language="javascript">
    <attribute name="logLevel"/>
    <![CDATA[
    var loglevel = attributes.get("loglevel");
    
    // create a stack of logLevel set
    var logLevelStack = project.getReference("misc.setLogLevel.stack");
    if (logLevelStack == null) {
      logLevelStack = new java.util.Stack();
      project.addReference("misc.setLogLevel.stack", logLevelStack);
    }
    
    // the default is 2 ==> warn
    var loglevelValue = 2;
    if (loglevel == "error") {
      loglevelValue = 0;
    } else if (loglevel == "warn") {
      loglevelValue = 1;
    } else if (loglevel == "info") {
      loglevelValue = 2;
    } else if (loglevel == "verbose") {
      loglevelValue = 3;
    } else if (loglevel == "debug") {
      loglevelValue = 4;
    }
    
    // get the logger
    var listener = project.getBuildListeners();
    var firstListener = listener.get(0);

    // keep the current logLevel
    var fields = firstListener.getClass().getDeclaredFields();
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      var fieldName = field.getName();
      
      // get the current logLevel
      if (fieldName.equals("msgOutputLevel")) {
        field.setAccessible(true);
        logLevelStack.push(field.get(firstListener));        
        field.setAccessible(false);
        break;
      }
    }
    
    // set the logLevel
    firstListener.setMessageOutputLevel(loglevelValue);
    ]]>
  </scriptdef>
  
  <scriptdef name="resetLogLevel" language="javascript">
    <![CDATA[
    var loglevelValue = 2;
    
    // create a stack of logLevel set
    var logLevelStack = project.getReference("misc.setLogLevel.stack");
    if (logLevelStack != null) {
      loglevelValue = logLevelStack.pop();
    }
    
    // set the logLevel
    var listener = project.getBuildListeners();
    var firstListener = listener.get(0);
    firstListener.setMessageOutputLevel(loglevelValue);
    ]]>
  </scriptdef>
  
  
  <scriptdef name="checkTarget" language="javascript" description="">
    <attribute name="property" />
    <attribute name="target" />
    <![CDATA[
    // the property to be set and the target to be checked
    var userProperty = attributes.get("property");
    var target = attributes.get("target");
    
    // the property to be read
    var property = "ant.project.cmd-invoked-targets";
    
    // get the property
    var foundEntry = false;
    var invokedTargets = project.getProperty(property);
    if (invokedTargets == null || invokedTargets.equals("")) {
    
      // create an error logger
      var errorMsg = project.createTask("echo");
      var error = Packages.org.apache.tools.ant.taskdefs.Echo.EchoLevel(); 
      error.setValue("error");
      errorMsg.setLevel(error);
      errorMsg.setMessage("The " + property + " is not available, please check the used starting routine and the used main-class.");
      errorMsg.perform();
    } else {
    
      // check the list of targets
      var listEntries = invokedTargets.split("\\s*,\\s*");
      var sizeOfList = listEntries.length;
      for (var i = 0; i < sizeOfList && !foundEntry; i++) {
        var entry = listEntries[i];
        foundEntry = foundEntry || entry.equals(target);
      }
    }
    
    // set the userProperty
    var setProperty = project.createTask("var");
    setProperty.setName(userProperty);
    setProperty.setValue("" + foundEntry);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    transformPackageToPath - transforms the passed (comma-separated) packages to a path which selects all
                             files (incl. files in sub-directories) from the package
    -->
  <scriptdef name="transformPackagesToPath" language="javascript">
    <attribute name="property" />
    <attribute name="packages" />
    <attribute name="suffix" />
    <attribute name="packageSeparatore" />
    <attribute name="separatore" />
    
    <![CDATA[
    var property = attributes.get("property");
    var packs = attributes.get("packages");
    var suffix = attributes.get("suffix");
    var packageSeparatore = attributes.get("packageseparatore");
    var separatore = attributes.get("separatore");
        
    if (packs == null || packs.trim() == "") {
      packs = "";
    } else {
      var split = packs.split(",");
      
      var pack = "";
      packs = "";
      for (var i = 0; i < split.length; i++) {
        pack = split[i].trim();
        pack = pack.replace('.', packageSeparatore);
        pack += suffix;
        
        packs += (packs == "" ? "" : separatore) + pack;
      }
    }
    
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(packs);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    createList - Creates a list based on an already created list, by appending a value to it only and 
                 only if its not in the list yet. The newly created list will never end on the passed separator
    -->
  <scriptdef name="createList" language="javascript">
    <attribute name="property" />
    <attribute name="list" />
    <attribute name="value" />
    <attribute name="separatore" />
    
    <![CDATA[
    var property = attributes.get("property");
    var list = attributes.get("list");
    var separatore = attributes.get("separatore");
    var value = attributes.get("value");
    value = value.trim();

    var listEntries = list.split("\\s*" + separatore + "\\s*");
    
    var finalList = "";
    var sizeOfList = listEntries.length;
    var foundEntry = false;
    for (var i = 0; i < sizeOfList; i++) {
      var entry = listEntries[i];
      var lastEntry = sizeOfList - 1 == i;
      foundEntry = foundEntry || entry.equals(value);
      
      finalList += entry + (lastEntry ? "" : separatore);
    }
    
    if (!foundEntry) {
      finalList += (sizeOfList > 0 && !finalList.equals("") ? separatore : "") + value;
    }
    
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(finalList);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <!--
    appendList - Appends a list (i.e. list1) to another list (i.e. list2), whereby duplicates will be removed
    -->
  <scriptdef name="appendList" language="javascript">
    <attribute name="property" />
    <attribute name="list1" />
    <attribute name="list2" />
    <attribute name="separator" />
    <attribute name="trimItems" />
    
    <![CDATA[
    var createSet = function(csvlist, separator, trim) {
      var set;
      
      if (csvlist == null || "".equals(csvlist)) {
        set = new java.util.LinkedHashSet();
      } else {
        var listEntries = csvlist.split("\\s*\\Q" + separator + "\\E\\s*");
        var list = java.util.Arrays.asList(listEntries);
        var set = new java.util.LinkedHashSet(list);
      }
      
      if (trim) {
        var trimmedSet = new java.util.LinkedHashSet();
        
        var iterator = set.iterator();
        while(iterator.hasNext()) {
          var value = iterator.next();
          trimmedSet.add(value.trim());
        }
        set = trimmedSet;
      }
      
      return set;
    };
      
    var property = attributes.get("property");
    var csvList1 = attributes.get("list1");
    var csvList2 = attributes.get("list2");
    var separator = attributes.get("separator");
    var trimItems = attributes.containsKey("trimitems") ? attributes.get("trimitems") : "false";
    trimItems = trimItems.equals("true") || trimItems.equals("yes") || trimItems.equals("y")
    
    // create the sets and merge those
    var set1 = createSet(csvList1, separator, trimItems);
    var set2 = createSet(csvList2, separator, trimItems);
    set1.addAll(set2);
            
    // build the new list
    var sb = new java.lang.StringBuilder();
    var loopSeparator = "";
    var iterator = set1.iterator();
    while(iterator.hasNext()) {
      sb.append(loopSeparator);
      sb.append(iterator.next());            
      loopSeparator = separator;
    }
    
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(sb.toString());
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="replacePropertiesInProperties" language="javascript">
    <attribute name="propertySetId" />
    <!-- optional attributes -->
    <attribute name="loopUntilAllReplaced" />    <!-- default: true -->
    <attribute name="sortAlphanumeric" />        <!-- default: false -->
    
    <![CDATA[
    var propertySetId = attributes.get("propertysetid");
    var loopUntilAllReplaced = attributes.containsKey("loopuntilallreplaced") ? attributes.get("loopuntilallreplaced").equals("true") : true;
    var sortAlphanumeric = attributes.containsKey("sortalphanumeric") ? attributes.get("sortalphanumeric").equals("true") : false;
    var properties = project.hasReference(propertySetId) ? project.getReference(propertySetId) : null;

    // get the properties
    if (properties != null && properties.size() > 0) {
      var changes = true;

      var propertyIter = properties.iterator();
      var set = sortAlphanumeric ? new java.util.TreeSet() : new java.util.LinkedHashSet();
      while (propertyIter.hasNext()) {
        set.add(propertyIter.next());
      }

      while (changes) {
        var propertyIter = set.iterator();
        changes = false;

        while (propertyIter.hasNext()) {
          var property = propertyIter.next();
          var propertyKey = property.getName();
          var propertyValue = property.getValue();
          var replacedNewValue = project.replaceProperties(propertyValue);
          var propertyNewValue = replacedNewValue;
          
          // we have to quote a property within the new value otherwise it would be replaced directly
          if (propertyNewValue != null) {
            var propertyRegEx = "\\$\\{[^\\}]+\\}";
            var propertyPattern = java.util.regex.Pattern.compile(propertyRegEx);
            var propertyMatcher = propertyPattern.matcher(propertyNewValue);
            var offset = 0;
            while (propertyMatcher.find()) {
              var replacePosition = propertyMatcher.start() + offset;
              propertyNewValue = new java.lang.String(propertyNewValue.substring(0, replacePosition) + "$" + propertyNewValue.substring(replacePosition));
              offset++;
            }
          }

          // set the new value if it changed
          if (!(propertyValue == null && replacedNewValue == null) && !propertyValue.equals(replacedNewValue)) {
            var setProperty = project.createTask("var");
            setProperty.setName(propertyKey);
            setProperty.setValue(propertyNewValue);
            setProperty.execute();
            changes = loopUntilAllReplaced;
          } 
        }
      }
    }
    ]]>
  </scriptdef>
  
  <!--
    createList - Creates a ResourceCollection into a list
    -->
  <scriptdef name="createResourceList" language="javascript">
    <attribute name="property" />
    <attribute name="resourceCollectionId" />
    <attribute name="separatore" />
    
    <![CDATA[
    var property = attributes.get("property");
    var resourceCollectionId = attributes.get("resourcecollectionid");
    var separatore = attributes.get("separatore");
    
    // get the resource collection
    var refs = project.hasReference(resourceCollectionId) ? project.getReference(resourceCollectionId) : null;
    
    // check the resource collection
    var finalList = "";
    if (refs != null && refs.size() > 0) {
      var entries = refs.iterator();
      
      finalList = separatore;
      while (entries.hasNext()) {
        var value;
        var entry = entries.next();
        if (entry instanceof org.apache.tools.ant.types.resources.PropertyResource ||
            entry instanceof org.apache.tools.ant.types.resources.StringResource) {
          value = entry.getValue();
        } else if (entry instanceof org.apache.tools.ant.types.resources.URLResource) {
          value = entry.getURL() == null ? "" : entry.getURL().toString();
        } else if (entry instanceof org.apache.tools.ant.types.resources.FileResource) {
          try {
            value = entry.getFile() == null ? "" : entry.getFile().getCanonicalPath();
          } catch (e) {
            value = entry.getFile() == null ? "" : entry.getFile().getAbsolutePath();
          }
        } else {
          value = entry == null ? "" : entry.toString();
        }
        
        finalList = finalList + value + separatore;
      }
      
      var length = separatore.length();
      var listLength = finalList.length;      
      finalList = finalList.substring(length, listLength - length);
    }
       
    var setProperty = project.createTask("var");
    setProperty.setName(property);
    setProperty.setValue(finalList);
    setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="popFromList" language="javascript">
    <attribute name="property" />
    <attribute name="list" />           <!-- if listProperty is set the property will be read if this one isn't set -->
    <attribute name="order" />          <!-- default="last" -->
    <attribute name="delimiter" />      <!-- default=","  -->
    <attribute name="modifyList" />     <!-- default="true"  -->
    <attribute name="listProperty" />   <!-- default=""  -->
    
    <![CDATA[
    var echo = project.createTask("echo");
    var setProperty = project.createTask("var");
    
    var property = attributes.get("property");
    var list = attributes.containsKey("list") ? attributes.get("list") : null;
    var takeFromLast = attributes.containsKey("order") ? attributes.get("order").equals("last") : true;
    var delimiter = attributes.containsKey("delimiter") ? attributes.get("delimiter") : ",";
    var modifyList = attributes.containsKey("modifylist") ? attributes.get("modifylist").equals("true") : true;
    var listProperty = attributes.containsKey("listproperty") ? attributes.get("listproperty") : "";
    
    // get the list
    if (list == null) {
      list = project.getProperty(listProperty);
    } 
    if (list == null || "".equals(list)) {
      arrayList = new java.util.ArrayList();
    } else {
      var listEntries = list.split("\\s*\\Q" + delimiter + "\\E\\s*");
      arrayList = new java.util.ArrayList(java.util.Arrays.asList(listEntries));
    }
    
    // get the first or last value of the list
    var pos = takeFromLast ? arrayList.size() - 1 : 0;
    var val = pos > -1 && pos < arrayList.size() ? arrayList.get(pos) : null;
    
    // set the property of the taken value
    setProperty.setName(property);
    setProperty.setValue(val == null ? "" : val);
    setProperty.execute();
    
    // modify the list if asked for
    if (modifyList && val != null && listProperty != null && !"".equals(listProperty)) {
      arrayList.remove(pos);
      
      // build the new list
      var sb = new java.lang.StringBuilder();
      var loopDelimiter = "";
      var iterator = arrayList.iterator();
      while(iterator.hasNext()) {
        sb.append(loopDelimiter);
        sb.append(iterator.next());            
        loopDelimiter = delimiter;
      }
      
      // set the new list
      setProperty.setName(listProperty);
      setProperty.setValue(sb.toString());
      setProperty.execute();
    }
    ]]>
  </scriptdef>
  
  <macrodef name="importLibrariesFromList">
    <attribute name="list" />
    <attribute name="default" default="true" />
    <attribute name="force" default="false" />
  
    <sequential>

      <for list="@{list}" param="misc.tmp.library">
        <sequential>
          <!-- reset the properties -->
          <var name="misc.tmp.relfile" value="" unset="true" />
          <var name="misc.tmp.import" value="" unset="true" />
          
          <!-- get the values of the defined properties -->
          <propertycopy name="misc.tmp.relfile" from="main.library.file.@{misc.tmp.library}" />
          <propertycopy name="misc.tmp.import" from="main.import.library.@{misc.tmp.library}" silent="true" />
          
          <!-- get the file and import it -->
          <if>
            <or>
              <equals arg1="@{force}" arg2="true" />
              <and>
                <isset property="misc.tmp.import" />
                <not><equals arg1="${misc.tmp.import}" arg2="false" /></not>
              </and>
              <and>
                <equals arg1="@{default}" arg2="true" />
                <not><isset property="misc.tmp.import" /></not>
              </and>
            </or>
            <then>
              <echo level="debug">Importing library: ${misc.tmp.relfile}</echo>
              <var name="misc.tmp.file" value="${library_main.basedir}/${misc.tmp.relfile}" />
              <import file="${misc.tmp.file}" />
            </then>
          </if>
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <macrodef name="callHookFromLibrary">
    <attribute name="library" />
    <attribute name="hook" />
    <attribute name="parameters" />
    
    <attribute name="failOnError" default="false" />
    
    <sequential>

    </sequential>
  </macrodef>
  
  <macrodef name="allLibrariesFiles">
    <attribute name="filesetid" />
  
    <sequential>
      <var name="misc.tmp.libraries" value="main,${main.import.order.core},${main.import.order.extension},${main.import.order.general},${main.import.order.proxy}" />
      
      <fileset id="@{filesetid}" dir="${main.root}">
        <exclude name="**/*" />
      </fileset>
     
      <for list="${misc.tmp.libraries}" param="misc.tmp.library">
        <sequential>
          <propertycopy name="misc.tmp.import" from="main.import.library.@{misc.tmp.library}" silent="true" />
            
          <if>
            <not><equals arg1="@{misc.tmp.library}" arg2="" /></not>
            <then>
              <libraryFiles library="@{misc.tmp.library}" filesetid="misc.tmp.libraryFiles" />

              <!-- create the unions -->
              <fileCombineFilesets filesetId="@{filesetid}">
                <fileset refid="misc.tmp.libraryFiles" />
                <fileset refid="@{filesetid}" />
              </fileCombineFilesets>
            </then>
          </if>
        </sequential>
      </for>
    </sequential>
  </macrodef>
  
  <macrodef name="libraryFiles">
    <attribute name="library" />
    <attribute name="filesetid" />
  
    <sequential>
      <var name="misc.tmp.library.files" value="" unset="true" />
    
      <propertyset id="misc.tmp.library.files">
        <propertyref regex="^@{library}\.library\.resfile\..+$" />
        <propertyref regex="^ant\.file\.library_@{library}$" />
      </propertyset>
 
      <!-- convert it to a path -->
      <pathconvert refid="misc.tmp.library.files" pathsep="," property="misc.tmp.library.files">
        <regexpmapper from="^\Q${main.root}\E[\\/](.+)$" to="\1"/>
      </pathconvert>
      
      <!-- get the fileset -->
      <if>
        <and>
          <isset property="misc.tmp.library.files" />
          <not><equals arg1="${misc.tmp.library.files}" arg2="" /></not>
        </and>
        <then>
          <fileset id="@{filesetid}" dir="${main.root}" includes="${misc.tmp.library.files}" />
        </then>
        <else>
          <echo level="warn">Warning: The @{library}-library was not included and therefore won't be included in the wrap-up</echo>
          <fileset id="@{filesetid}" dir="${main.root}">
            <exclude name="**/*" />
          </fileset>
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="asyncExec">
    <attribute name="exec" />
    <attribute name="title" default="ant async exec" />
    <attribute name="workingDir" default ="." />
    <attribute name="arg1" default ="" />
    <attribute name="arg2" default ="" />
    <attribute name="arg3" default ="" />
    <attribute name="arg4" default ="" />
    <attribute name="arg5" default ="" />
    
    <sequential>
      <exec executable="${misc.batch.genericPath}" dir="@{workingDir}" vmlauncher="false" failonerror="true">
        <env key="ANTRUN_TITLE" value="@{title}" />
        <!-- actual executable and arguments to run -->
        <arg line="@{exec}" />
        <arg line="@{arg1}" />
        <arg line="@{arg2}" />
        <arg line="@{arg3}" />
        <arg line="@{arg4}" />
        <arg line="@{arg5}" />
      </exec>
    </sequential>
  </macrodef>
  
  <macrodef name="modifyProperties">
    <attribute name="prefix" />
    <attribute name="propertySetId" default="misc.tmp.propertySet" />
    <attribute name="resultPropertySetId" default="misc.tmp.resultPropertySet" />
    <attribute name="setPropertiesWithoutPrefix" default="true" />
    <attribute name="unsetProperties" default="false" />
    <attribute name="skipPattern" default="" />
    
    <sequential>
      <var name="misc.tmp.propertyRegEx" value="^\Q@{prefix}\E\.(.+)$" />
      <var name="misc.tmp.propertySetId" value="@{propertySetId}" />
      <var name="misc.tmp.resultPropertySetId" value="@{resultPropertySetId}" />
      <var name="misc.tmp.skipPattern" value="@{skipPattern}" />
      <if>
        <or><equals arg1="@{setPropertiesWithoutPrefix}" arg2="y" /><equals arg1="@{setPropertiesWithoutPrefix}" arg2="yes" /><equals arg1="@{setPropertiesWithoutPrefix}" arg2="true" /></or>
        <then><var name="misc.tmp.setPropertiesWithoutPrefix" value="true" /></then>
        <else><var name="misc.tmp.setPropertiesWithoutPrefix" value="false" /></else>
      </if>
      <if>
        <or><equals arg1="@{unsetProperties}" arg2="y" /><equals arg1="@{unsetProperties}" arg2="yes" /><equals arg1="@{unsetProperties}" arg2="true" /></or>
        <then><var name="misc.tmp.unsetProperties" value="true" /></then>
        <else><var name="misc.tmp.unsetProperties" value="false" /></else>
      </if>
      
      <!-- create the set -->
      <propertyset id="@{propertySetId}">
        <propertyref regex="${misc.tmp.propertyRegEx}" />
      </propertyset>
      
      <!-- set the properties without a prefix -->
      <if>
        <or><equals arg1="${misc.tmp.setPropertiesWithoutPrefix}" arg2="true" /><equals arg1="${misc.tmp.unsetProperties}" arg2="true" /></or>
        <then>

          <script language="javascript"><![CDATA[
            var propertyRegEx = project.getProperty("misc.tmp.propertyRegEx");
            var propertySetId = project.getProperty("misc.tmp.propertySetId");
            var resultPropertySetId = project.getProperty("misc.tmp.resultPropertySetId");
            var setPropertiesWithoutPrefix = project.getProperty("misc.tmp.setPropertiesWithoutPrefix");
            var unsetProperties = project.getProperty("misc.tmp.unsetProperties");
            var skipPattern = project.getProperty("misc.tmp.skipPattern");
            
            // get the collection
            var properties = project.hasReference(propertySetId) ? project.getReference(propertySetId) : null;
            
            // create the result property set
            var resultPropertySet = new org.apache.tools.ant.types.PropertySet();
            resultPropertySet.setProject(project);
            
            // iteratore over the properties
            if (properties != null && properties.size() > 0) {
              var iterator = properties.iterator();

              while (iterator.hasNext()) {              
                var property = iterator.next();
                var propertyPattern = java.util.regex.Pattern.compile(propertyRegEx);
                var propertyMatcher = propertyPattern.matcher(property.getName());
                
                // trigger the regex we will find something and get the value
                propertyMatcher.find();
                var propertySuffix = propertyMatcher.group(1);
                
                // set the property if asked for
                if ("true".equals(setPropertiesWithoutPrefix) && 
                    ("".equals(skipPattern) || !propertySuffix.matches(".*" + skipPattern + ".*"))) {
                  var setProperty = project.createTask("var");
                  setProperty.setName(propertySuffix);
                  setProperty.setValue(property.getValue());
                  setProperty.execute();
                  
                  var propertyRef = new org.apache.tools.ant.types.PropertySet.PropertyRef();
                  propertyRef.setRegex("^\\Q" + propertySuffix + "\\E$");
                  resultPropertySet.addPropertyref(propertyRef);
                }
                
                // unset the property if asked for
                if ("true".equals(unsetProperties)) {
                  var unsetProperty = project.createTask("var");
                  unsetProperty.setName(property.getName());
                  unsetProperty.setValue(null);
                  unsetProperty.setUnset(true);
                  unsetProperty.execute();
                }
              }
            }
            
            project.addReference(resultPropertySetId, resultPropertySet);
          ]]></script>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="varKeep">
    <attribute name="name" />
    <attribute name="value" />
    <attribute name="property" />
    
    <sequential>
      <var name="@{property}" value="" unset="true" />
      <propertycopy name="@{property}" from="@{name}" />
      <var name="@{name}" value="@{value}" />
    </sequential>
  </macrodef>
  
  <macrodef name="varNvl">
    <attribute name="property" />
    <attribute name="value" />
    
    <sequential>
      <if>
        <not><isset property="@{property}" /></not>
        <then>
          <var name="@{property}" value="@{value}" />
        </then>
      </if>
    </sequential>
  </macrodef>
</project>