<!--
  Library which adds some macros and targets for file operations/modifications
  
  Created on: 01.03.2012
  Created by: Philipp Meisen <philipp@meisen.net>
  History:
    01.03.2012
      - Creation of library
  -->
<project name="library_file">
  <property name="file.library.version" value="2.0.0" description="The current version of the library" />
  <dirname property="library_file.basedir" file="${ant.file.library_file}" />
  
  <property name="file.library.resfile.default.merge" location="${library_eclipse.basedir}/library_file_xmlMerge.properties" />

  <!--
    add the antcontrib library
    -->
  <taskdef resource="net/sf/antcontrib/antlib.xml" />
  <!--
    include additional tasks
    -->
  <taskdef name="xmlmerge" classname="ch.elca.el4j.services.xmlmerge.anttask.XmlMergeTask" />
  
  <!--
    fileCleanUp - should be called to clean a directory (i.e. deletes all files and directories)
    -->
  <macrodef name="fileCleanUp">   
    <attribute name="dir" />
    <attribute name="recreate" default="true" />
    <attribute name="failonerror" default="true" />

    <sequential>
      <echo level="info">Cleaning folder '@{dir}'</echo>
      <delete dir="@{dir}" failonerror="@{failonerror}" />
      
      <if>
        <or><equals arg1="@{recreate}" arg2="y" /><equals arg1="@{recreate}" arg2="yes" /><equals arg1="@{recreate}" arg2="true" /></or>
        <then>
            <mkdir dir="@{dir}" />
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="filePrintFileset">   
    <attribute name="filesetid" />

    <sequential>
    
      <!-- print the fileset -->
      <pathconvert pathsep="${line.separator}" property="file.tmp.fileset" refid="@{filesetid}"/>
      <echo>${file.tmp.fileset}</echo>
      
      <var name="file.tmp.fileset" unset="true" />
    </sequential>
  </macrodef>
  
  <!--
    fileReplaceAllProperties - creates a copy of the specified file, whereby all known ant-properties are replaced
    -->
  <macrodef name="fileReplaceAllProperties">
    <attribute name="file" />
    <attribute name="destFile" />
    <attribute name="tmp" default="${main.tmpdir}" />

    <sequential>
    
      <!-- files with zero length cannot be property-replaced -->
      <if>
        <and>
          <length file="@{file}" when="greater" length="0" />
          <matches string="@{file}" pattern="(?:\.xml|\.properties|\.html|\.txt|\.bat|\.mf|\.project|\.classpath|\.template)$" casesensitive="false" />
        </and>
        <then>   
          <!-- replace all the properties of the file specified -->
          <copy file="@{file}" tofile="${main.tmpdir}/file.tmp" overwrite="true">
            <filterchain>
              <expandproperties/>
            </filterchain>
          </copy>
          
          <copy file="${main.tmpdir}/file.tmp" tofile="@{destFile}" overwrite="true" />
        </then>
        <else>
        <echo>---> @{file}</echo>
          <copy file="@{file}" tofile="@{destFile}" overwrite="true" />
        </else>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="fileReplaceAllPropertiesInZip">
    <attribute name="file" />
    <attribute name="dest" />
    <attribute name="tmp" default="${main.tmpdir}" />
    <attribute name="rezip" default="true" />
    <attribute name="excludes" default="" />

    <sequential>
    
      <if>
        <matches string="@{file}" pattern="(?:\.zip|\.jar)$" casesensitive="false" />
        <then>
          <!-- generate a temporary directory -->
          <generateUUID property="file.tmp.stagingArea" />
          <var name="file.tmp.stagingArea" value="${main.tmpdir}/${file.tmp.stagingArea}" />
          <fileCleanUp dir="${file.tmp.stagingArea}" />
          
          <if>
            <or><equals arg1="@{rezip}" arg2="y" /><equals arg1="@{rezip}" arg2="yes" /><equals arg1="@{rezip}" arg2="true" /></or>
            <then>
              <generateUUID property="file.tmp.destLocation" />
              <var name="file.tmp.destLocation" value="${main.tmpdir}/${file.tmp.destLocation}" />
              <fileCleanUp dir="${file.tmp.destLocation}" />
            </then>
            <else>
              <var name="file.tmp.destLocation" value="@{dest}" />
            </else>
          </if>
                    
          <!-- first copy the once with possibility to replace -->
          <unzip src="@{file}" dest="${file.tmp.stagingArea}" overwrite="true">
            <patternset excludes="@{excludes}" includes="**/*.xml,**/*.properties,**/*.html,**/*.txt,**/*.bat,**/*.mf,**/*.project,**/*.classpath,**/*.template" />
          </unzip>

          <!-- copy and replace properties -->
          <copy todir="${file.tmp.destLocation}">
            <fileset dir="${file.tmp.stagingArea}" />
            <filterchain>
              <expandproperties/>
            </filterchain>
          </copy>
          
          <!-- now copy the rest -->
          <unzip src="@{file}" dest="${file.tmp.destLocation}">
            <patternset excludes="@{excludes},**/*.xml,**/*.properties,**/*.html,**/*.txt,**/*.bat,**/*.mf,**/*.project,**/*.classpath,**/*.template" />
          </unzip>
          
          <!-- zip the stuff -->
          <if>
            <or><equals arg1="@{rezip}" arg2="y" /><equals arg1="@{rezip}" arg2="yes" /><equals arg1="@{rezip}" arg2="true" /></or>
            <then>
              <zip destfile="@{dest}" basedir="${file.tmp.destLocation}" />
              
              <!-- cleanup the location -->
              <fileCleanUp dir="${file.tmp.destLocation}" recreate="false" />
            </then>
          </if>
          
          <!-- cleanUp -->
          <fileCleanUp dir="${file.tmp.stagingArea}" recreate="false" />
        </then>
        <else>
          <echo level="warn">You are trying to replace properties in a file which is not a zip or a jar</echo>
        </else>
      </if>
    </sequential>
  </macrodef>

  <macrodef name="fileMergeXml">
    <attribute name="file1" />
    <attribute name="file2" />
    <attribute name="dest" />
    <attribute name="conf" default="${file.library.resfile.default.merge}" />

    <sequential>
      <!-- check if file2 really exists -->
      <if>
        <available file="@{file2}"/>
        <then>
        
          <!-- remove the old version -->
          <delete file="@{dest}" />      

          <!-- create the new merge -->
          <xmlmerge dest="@{dest}" conf="@{conf}">
            <fileset file="@{file1}" />
            <fileset file="@{file2}" />
          </xmlmerge>
        </then>
        <else>
          <copy file="@{file1}" tofile="@{dest}" overwrite="true" />
        </else>
      </if>
    </sequential>
  </macrodef>
    
  <macrodef name="runAnt">
    <attribute name="directory" default="." />
    <attribute name="targets" />
    <attribute name="parameters" default="" />
    <attribute name="dirPattern" default=".*" />
  
    <sequential>
      <basename file="@{directory}" property="dirname"/>
      
      <var name="buildDir" value="@{directory}/trunk" />
      <var name="buildFile" value="${buildDir}/build.xml" />

      <if>
        <and>
          <matches pattern="@{dirPattern}" string="${dirname}"/>
          <resourceexists>
            <file file="${buildFile}"/>
          </resourceexists>
        </and>
        <then>
          <echo level="info">Running targets @{targets} for ${dirname}</echo>
          <exec dir="${buildDir}" executable="cmd.exe">
            <arg line="/c ant @{targets} @{parameters}"/>
          </exec>
        </then>
      </if>
    </sequential>
  </macrodef>
  
  <macrodef name="doTargetForEachFolder">
    <attribute name="includes" default="*" />
    <attribute name="excludes" default="" />
    <attribute name="targets" />
    <attribute name="parameters" default="" />
    <attribute name="dirPattern" default=".*" />
    
    <sequential>
      <var name="file.tmp.wrapperTargets" value="@{targets}" />
      <var name="file.tmp.wrapperParameters" value="@{parameters}" />
      <var name="file.tmp.wrapperDirPattern" value="@{dirPattern}" />

      <foreach target="fileWrapperRunAnt" param="directory">
        <path>
          <dirset dir="." includes="@{includes}" excludes="@{excludes}" />
        </path>
      </foreach>
    </sequential>
  </macrodef>
  
  <!--
    Just a wrapper target to do the foreach
    -->
  <target name="fileWrapperRunAnt">
    <runAnt directory="${directory}" targets="${file.tmp.wrapperTargets}" parameters="${file.tmp.wrapperParameters}" dirPattern="${file.tmp.wrapperDirPattern}" />
  </target>
  
  <scriptdef name="fileInfo" language="javascript">
    <attribute name="file" />
    
    <![CDATA[   
      var fileName = attributes.get("file");
      var file = new java.io.File(fileName);
      
      var setFileName = project.createTask("var");
      setFileName.setName("fileInfo.name");
      setFileName.setValue(file.getName());
      setFileName.execute();
      
      var ext = file.getName();
      var i = ext.lastIndexOf(".");
      if (i > 0 && i < ext.length() - 1) {
        ext = ext.substring(i + 1).toLowerCase();
      } else {
        ext = "";
      }
      var setFileExtension = project.createTask("var");
      setFileExtension.setName("fileInfo.extension");
      setFileExtension.setValue(ext);
      setFileExtension.execute();
      
      var setFileType = project.createTask("var");
      setFileType.setName("fileInfo.dir");
      setFileType.setValue(file.isDirectory());
      setFileType.execute();
      
      var setFileExists = project.createTask("var");
      setFileExists.setName("fileInfo.exist");
      setFileExists.setValue(file.exists());
      setFileExists.execute();
      
      var setFileDir = project.createTask("var");
      setFileDir.setName("fileInfo.directory");
      setFileDir.setValue(file.isDirectory() ? file.getAbsolutePath() : file.getParent());
      setFileDir.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileFilterFilesetByDirset" language="javascript">
    <attribute name="filteredSetId" />
    <attribute name="filteredSetBase" />
    <element name="fileset" type="fileset" />
    <element name="dirset" type="dirset" />
    
    <![CDATA[
      var filesets = elements.get("fileset");
      var dirsets = elements.get("dirset");
      var filteredSetId = attributes.get("filteredsetid");
      var filteredSetBase = attributes.get("filteredsetbase");
      
      // create the new fileset
      var fsFiltered = project.createDataType("fileset");
      fsFiltered.setDir(new java.io.File(filteredSetBase));
      // fsFiltered.setExcludes("**/*");
      project.addReference(filteredSetId, fsFiltered);
      
      // check each file
      var addedCount = 0;
      for (i = 0; i < filesets.size(); ++i) {
        var fileset = filesets.get(i);
        var fsBaseDir = fileset.getDir(project);
        
        // get the files of the set
        var fsScanner = fileset.getDirectoryScanner(project);
        var fsFiles = fsScanner.getIncludedFiles();
       
        // check each file
        for (j = 0; j < fsFiles.length; ++j) {
          var fileName = fsFiles[j];
          var file = new java.io.File(fsBaseDir, fileName);
        
          // check if the file is within the dirsets
          var found = false;
          for (k = 0; k < dirsets.size() && !found; ++k) {
            var dirset = dirsets.get(k);
            var dsBaseDir = dirset.getDir(project);
            
            // get the directories of the set
            var dsScanner = dirset.getDirectoryScanner(project);
            var dsDir = dsScanner.getIncludedDirectories();

            // check all the directories
            for (l = 0; l < dsDir.length && !found; ++l) {
              var dirName = dsDir[l];
              var dir = new java.io.File(dsBaseDir, dirName);
              
              // check if the file is located within the directory
              var parent = file.getParentFile();
              while(!found && parent != null) {
                  if(dir.equals(parent)) {
                      found = true;
                  }

                  parent = parent.getParentFile();
              }
            }
          }
          
          // add the file
          if (!found) {
            var absPath = file.getAbsolutePath();
            if (absPath.startsWith(filteredSetBase)) {
              var inc = fsFiltered.createInclude();
              inc.setName(absPath.substring(filteredSetBase.length() + 1).replace("\\", "/"));
              
              // incremeant the count
              addedCount++;
            }
          }
        }
      }
      
      // check if we added something
      if (addedCount == 0) {
        var ex = fsFiltered.createExclude();
        ex.setName("**/*");
      }
    ]]>
  </scriptdef>

  <scriptdef name="fileCallMacroForEach" language="javascript">
    <attribute name="macro" />
    <!-- the following attributes are optional -->
    <attribute name="regExpFilter" />
    <attribute name="parameters" />
    <element name="fileset" type="fileset" />
    
    <![CDATA[
      var macro = attributes.get("macro");
      var regExpFilter = attributes.containsKey("regexpfilter") ? attributes.get("regexpfilter") : ".*";;
      var parameters = attributes.containsKey("parameters") ? attributes.get("parameters") : "";
      var parameterList = parameters.equals("") ? new Array() : parameters.split("\\]\\]\\s*(;\\s*|\\s*$)");
      var filesets = elements.get("fileset");
      
      for (i = 0; i < filesets.size(); ++i) {
        var fileset = filesets.get(i);
        var baseDir = fileset.getDir(project);
      
        // get the files of the set
        var scanner = fileset.getDirectoryScanner(project);
        var files = scanner.getIncludedFiles();

        // check each file
        for (j = 0; j < files.length; ++j) {
          var file = files[j];
          var src = new java.io.File(baseDir, file);

          // check the pattern
          if (src.getAbsolutePath().matches(regExpFilter)) {
            var runMacro = project.createTask(macro);
           
            var attributes = runMacro.getMacroDef().getAttributes();
            for (var i = 0; i < attributes.size(); ++i) {
              var att = attributes.get(i);
              
              if (att == null) {
                continue;
              } else if (att.getName().equals("resourcefolder")) {
                runMacro.setDynamicAttribute("resourcefolder", src.getParent());
              } else if (att.getName().equals("resourcefilename")) {
                runMacro.setDynamicAttribute("resourcefilename", src.getName());
              } else if (att.getName().equals("resource")) {
                runMacro.setDynamicAttribute("resource", src);
              } else if (att.getName().equals("basedir")) {
                runMacro.setDynamicAttribute("basedir", baseDir);
              }
            }
            
            // set the dynamic values
            for (i = 0; i < parameterList.length; ++i) {
              var keyValue = parameterList[i].split("\\s*=\\s*\\[\\[");             
              runMacro.setDynamicAttribute(keyValue[0].toLowerCase(), keyValue[1]);
            }
            
            runMacro.execute();
          }
        }
      }
    ]]>
  </scriptdef>
  
  <scriptdef name="fileGetSubPath" language="javascript">
    <attribute name="basedir" />
    <attribute name="file" />
    <!-- the following attributes are optional -->
    <attribute name="isDir" />
    <attribute name="property" />
    <attribute name="removePrefix" />
    
    <![CDATA[
      var basedir = attributes.get("basedir");
      var file = attributes.get("file");
      var property = attributes.containsKey("property") ? attributes.get("property") : "file.subpath";
      var isdir = attributes.containsKey("isdir") ? attributes.get("isdir") : "" + (new java.io.File(file).isDirectory());
      var removePrefix = attributes.containsKey("removeprefix") ? attributes.get("removeprefix") : "";

      // get the file to look for
      var baseFile = new java.io.File(basedir);
      var fileFile = new java.io.File(file);
      
      // check if we have a file and get the directory
      if (!isdir.equals("true")) {
        fileFile = fileFile.getParentFile();
      }
      
      // get the relative path
      var relativePath = baseFile.toURI().relativize(fileFile.toURI()).getPath();
      
      // remove any separaters
      if (relativePath.endsWith("\\") || relativePath.endsWith("/")) {
        relativePath = relativePath.substring(0, relativePath.length() - 1);
      }
      
      // remove any prefix
      if (removePrefix != null && !"".equals(removePrefix)) {
        removePrefix = removePrefix.startsWith("\\") || removePrefix.startsWith("/") ? removePrefix.substring(1) : removePrefix;          
        var prefixFile = new java.io.File(removePrefix);
        var relativeFile = new java.io.File(relativePath);
        relativePath = prefixFile.toURI().relativize(relativeFile.toURI()).getPath();
      }
      
      // empty means the current, i.e. .
      if (relativePath.equals("")) {
        relativePath = ".";
      }

      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(relativePath);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileCreateFileList" language="javascript">
    <attribute name="dir" />
    <attribute name="property" />
    <!-- the following attributes are optional -->
    <attribute name="basedir" />
    <attribute name="basedirReplacement" />
    
    <![CDATA[
      var property = attributes.get("property");
      var dir = attributes.get("dir");
      var dirFile = new java.io.File(dir);
      var basedir = attributes.containsKey("basedir") ? attributes.get("basedir") : dirFile.getPath();
      var basedirreplacement = attributes.containsKey("basedirreplacement") ? attributes.get("basedirreplacement") : "";
      
      // get the list
      var csvFiles = "";
      var stack = new java.util.Stack();
      stack.push(dirFile);
      while(!stack.isEmpty()) {
        var child = stack.pop();
        if (child.isDirectory()) {
          var files = child.listFiles();
        
          for(var i = 0; i < files.length; i++) {
            var f = files[i];
            stack.push(f);
          }
        } else if (child.isFile()) {
          
          // remove the basedir
          var file = child.getPath();
          file = file.replace(basedir, basedirreplacement);
          
          // remove any leading file separater this is normally bad
          if (!"".equals(basedir) && file.startsWith("\\") || file.startsWith("/")) {
            file = file.substring(1);
          }
        
          csvFiles += "," + file;
        }
      }
      
      // remove any trailing comma
      if (!"".equals(csvFiles)) {
        csvFiles = csvFiles.substring(1);
      }
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(csvFiles);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileCombineFilesets" language="javascript">
    <attribute name="filesetid" />
    <element name="fileset" type="fileset" />
    
    <![CDATA[
      var filesetId = attributes.get("filesetid");
      var filesets = elements.get("fileset");
            
      // create the stuff we need
      var basedir = null;
      var files = new java.util.ArrayList();
              
      // check each file
      for (var i = 0; i < filesets.size(); ++i) {      
        var fileset = filesets.get(i);
        var fsBaseDir = fileset.getDir(project);
        
        if (basedir == null) {
          basedir = fsBaseDir;          
        } else if (basedir != null && !basedir.equals(fsBaseDir)) {
          throw new java.lang.IllegalArgumentException("The base directories of the filesets must match '" + basedir + "' != '" + fsBaseDir + "'");
        }
        
        // get the files of the set
        var fsScanner = fileset.getDirectoryScanner(project);
        var fsFiles = fsScanner.getIncludedFiles();
       
        // check each file
        for (j = 0; j < fsFiles.length; ++j) {
          var fileName = fsFiles[j];
          var file = new java.io.File(basedir, fileName);
          
          // add the file
          files.add(file);
        }
      }
      
      // create the new fileset
      if (basedir == null) {
        throw new java.lang.IllegalArgumentException("You have to past at least one fileset");
      } else {
        var fs = project.createDataType("fileset");
        fs.setDir(new java.io.File(basedir));
        
        // add the refered fileset
        project.addReference(filesetId, fs);

        // get the file relative to the basedir
        for (var i = 0; i < files.size(); ++i) {
          var file = files.get(i);
          var relativePath = basedir.toURI().relativize(file.toURI()).getPath();

          // add all the files relative to the basedir
          var inc = fs.createInclude();
          inc.setName(relativePath);
        }
      }
    ]]>
  </scriptdef>

  <scriptdef name="fileAppendSuffix" language="javascript">
    <attribute name="property" />
    <attribute name="file" />
    <attribute name="suffix" />
    
    <![CDATA[
      var property = attributes.get("property");
      var fileName = attributes.get("file");
      var suffix = attributes.get("suffix");
      
      var file = new java.io.File(fileName);
      var name = file.getName();
      var i = name.contains(".") ? name.lastIndexOf('.') : name.length();
      
      var modName = name.substring(0, i) + suffix + name.substring(i);
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(modName);
      setProperty.execute();
    ]]>
  </scriptdef>
  
  <scriptdef name="fileReplaceName" language="javascript">
    <attribute name="property" />
    <attribute name="file" />
    <attribute name="renameTo" />
    
    <![CDATA[
      var property = attributes.get("property");
      var filePath = attributes.get("file");
      var renameTo = attributes.get("renameto");
      
      var file = new java.io.File(filePath);
      var parent = file.getParent();
      var newFile = new java.io.File(parent, renameTo);
      
      // set the property
      var setProperty = project.createTask("var");
      setProperty.setName(property);
      setProperty.setValue(newFile);
      setProperty.execute();
    ]]>
  </scriptdef>
</project>